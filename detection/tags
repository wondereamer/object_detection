!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
ACT_AREA_BIAS	cluster_node.cpp	471;"	d	file:
AdjIter	graph.h	/^        typedef typename BaseGraph<GraphContainer>::AdjIter AdjIter;$/;"	t	class:m_graph::AutoUniGraph	access:public
AdjIter	graph.h	/^        typedef typename BaseGraph<GraphContainer>::AdjIter AdjIter;$/;"	t	class:m_graph::ManualUniGraph	access:public
AdjIter	graph.h	/^        typedef typename graph_traits<GraphContainer>::adjacency_iterator AdjIter;$/;"	t	class:m_graph::BaseGraph	access:public
AdjRange	graph.h	/^        typedef std::pair<AdjIter, AdjIter> AdjRange;$/;"	t	class:m_graph::AutoUniGraph	access:public
AdjRange	graph.h	/^        typedef std::pair<AdjIter, AdjIter> AdjRange;$/;"	t	class:m_graph::BaseGraph	access:public
AdjRange	graph.h	/^        typedef std::pair<AdjIter, AdjIter> AdjRange;$/;"	t	class:m_graph::ManualUniGraph	access:public
AtA	cluster_node.h	/^        SymMatrix4x4 AtA;      \/\/!< To find bf-sphere (matrix)$/;"	m	class:ClusterNode	access:public
Atb	cluster_node.h	/^        double Atb[4];         \/\/!< To find bf-sphere (known term)$/;"	m	class:ClusterNode	access:public
AutoUniGraph	graph.h	/^        AutoUniGraph (){$/;"	f	class:m_graph::AutoUniGraph	access:public	signature:()
AutoUniGraph	graph.h	/^        AutoUniGraph (int numNode):BaseGraph<GraphContainer>(numNode){$/;"	f	class:m_graph::AutoUniGraph	access:public	signature:(int numNode)
AutoUniGraph	graph.h	/^class AutoUniGraph :public BaseGraph<GraphContainer>{$/;"	c	namespace:m_graph	inherits:BaseGraph
BOOST_INSTALL_PROPERTY	graph.h	/^    BOOST_INSTALL_PROPERTY(vertex, node);$/;"	p	namespace:boost	signature:(vertex, node)
BaseGraph	graph.h	/^        BaseGraph() {$/;"	f	class:m_graph::BaseGraph	access:public	signature:()
BaseGraph	graph.h	/^        BaseGraph(const BaseGraph& g) : _g(g._g) {$/;"	f	class:m_graph::BaseGraph	access:public	signature:(const BaseGraph& g)
BaseGraph	graph.h	/^        BaseGraph(int numNode) :_g(numNode){$/;"	f	class:m_graph::BaseGraph	access:public	signature:(int numNode)
BaseGraph	graph.h	/^class BaseGraph$/;"	c	namespace:m_graph
BiMap	icp.h	/^    typedef boost::bimaps::bimap< int, int > BiMap;$/;"	t	class:IterativeClosestPoint	access:private
BiValue	icp.h	/^    typedef BiMap::value_type BiValue;$/;"	t	class:IterativeClosestPoint	access:private
BinaryTree	cluster_node.h	/^class BinaryTree: public HieraTree$/;"	c	inherits:HieraTree
BinaryTree::NodeId	cluster_node.h	/^        typedef HieraTree::NodeId NodeId;$/;"	t	class:BinaryTree	access:public
BinaryTree::_currentNode	cluster_node.cpp	/^TrNode BinaryTree::_currentNode;$/;"	m	class:BinaryTree	file:
BinaryTree::_currentNode	cluster_node.h	/^        static TrNode _currentNode;$/;"	m	class:BinaryTree	access:public
BinaryTree::_inStack	cluster_node.h	/^        std::stack<NodeId> _inStack;$/;"	m	class:BinaryTree	access:public
BinaryTree::_outStack	cluster_node.h	/^        std::stack<NodeId> _outStack;           \/\/ could replace stack with vector $/;"	m	class:BinaryTree	access:public
BinaryTree::brotherId	cluster_node.h	/^        NodeId brotherId(NodeId id){$/;"	f	class:BinaryTree	access:public	signature:(NodeId id)
BinaryTree::childrenId	cluster_node.h	/^        std::pair<NodeId, NodeId> childrenId(NodeId p){$/;"	f	class:BinaryTree	access:public	signature:(NodeId p)
BinaryTree::is_brother_of_out	cluster_node.h	/^        bool is_brother_of_out(NodeId t){$/;"	f	class:BinaryTree	access:public	signature:(NodeId t)
BinaryTree::parentId	cluster_node.h	/^        NodeId parentId(NodeId id){$/;"	f	class:BinaryTree	access:public	signature:(NodeId id)
Block	pixel.h	/^typedef GrayPixel3D Block;$/;"	t
CHANELS	pixel.h	/^        static const int CHANELS = 1;$/;"	m	class:GrayPixel2D	access:public
CHANELS	pixel.h	/^        static const int CHANELS = 3;$/;"	m	class:RgbPixel2D	access:public
COMPONENT_H	component.h	4;"	d
CloudVector	vizblockworld.h	/^typedef std::vector<pcl::PointCloud<PointT>::Ptr> CloudVector;$/;"	t
ClusterNode	cluster_node.cpp	/^ClusterNode::ClusterNode(Triangle *t, int index, int cId)$/;"	f	class:ClusterNode	signature:(Triangle *t, int index, int cId)
ClusterNode	cluster_node.h	/^        ClusterNode(){ }$/;"	f	class:ClusterNode	access:public	signature:()
ClusterNode	cluster_node.h	/^        ClusterNode(Triangle *, int, int);	\/\/ Constructor$/;"	p	class:ClusterNode	access:public	signature:(Triangle *, int, int)
ClusterNode	cluster_node.h	/^class ClusterNode : public graphNode$/;"	c	inherits:graphNode
ClusterNode::AtA	cluster_node.h	/^        SymMatrix4x4 AtA;      \/\/!< To find bf-sphere (matrix)$/;"	m	class:ClusterNode	access:public
ClusterNode::Atb	cluster_node.h	/^        double Atb[4];         \/\/!< To find bf-sphere (known term)$/;"	m	class:ClusterNode	access:public
ClusterNode::ClusterNode	cluster_node.cpp	/^ClusterNode::ClusterNode(Triangle *t, int index, int cId)$/;"	f	class:ClusterNode	signature:(Triangle *t, int index, int cId)
ClusterNode::ClusterNode	cluster_node.h	/^        ClusterNode(){ }$/;"	f	class:ClusterNode	access:public	signature:()
ClusterNode::ClusterNode	cluster_node.h	/^        ClusterNode(Triangle *, int, int);	\/\/ Constructor$/;"	p	class:ClusterNode	access:public	signature:(Triangle *, int, int)
ClusterNode::Cov_c	cluster_node.h	/^        SymMatrix3x3 Cov_c;    \/\/!< Covariance matrix of normal variation$/;"	m	class:ClusterNode	access:public
ClusterNode::Cov_v	cluster_node.h	/^        SymMatrix3x3 Cov_v;    \/\/!< Covariance matrix of cluster vertices$/;"	m	class:ClusterNode	access:public
ClusterNode::_centerIds	cluster_node.h	/^        std::list<int> _centerIds;            \/\/!< id of center points $/;"	m	class:ClusterNode	access:public
ClusterNode::_cloud	cluster_node.cpp	/^pcl::PointCloud<PointT>::Ptr ClusterNode::_cloud;$/;"	m	class:ClusterNode	file:
ClusterNode::_cloud	cluster_node.h	/^        static pcl::PointCloud<PointT>::Ptr _cloud;$/;"	m	class:ClusterNode	access:private
ClusterNode::areas	cluster_node.h	/^        List areas;            \/\/!< Triangle areas$/;"	m	class:ClusterNode	access:public
ClusterNode::bestFittingCircle	cluster_node.cpp	/^bool ClusterNode::bestFittingCircle(double *pts, int numpts, double& x0, double &y0, double& r)$/;"	f	class:ClusterNode	signature:(double *pts, int numpts, double& x0, double &y0, double& r)
ClusterNode::bestFittingCircle	cluster_node.h	/^        static bool bestFittingCircle(double *, int, double&, double&, double&);$/;"	p	class:ClusterNode	access:public	signature:(double *, int, double&, double&, double&)
ClusterNode::bestFittingSphere	cluster_node.cpp	/^bool ClusterNode::bestFittingSphere(SymMatrix4x4& AtA, double *Atb, double& x0, double &y0, double &z0, double& r)$/;"	f	class:ClusterNode	signature:(SymMatrix4x4& AtA, double *Atb, double& x0, double &y0, double &z0, double& r)
ClusterNode::bestFittingSphere	cluster_node.h	/^        static bool bestFittingSphere(SymMatrix4x4&, double *, double&, double&, double&, double&);$/;"	p	class:ClusterNode	access:public	signature:(SymMatrix4x4&, double *, double&, double&, double&, double&)
ClusterNode::childId	cluster_node.h	/^        int childId;$/;"	m	class:ClusterNode	access:public
ClusterNode::cluster	cluster_node.cpp	/^BinaryTree& ClusterNode::cluster(MyTriangulation *tin){$/;"	f	class:ClusterNode	signature:(MyTriangulation *tin)
ClusterNode::cluster	cluster_node.h	/^        static BinaryTree &cluster(MyTriangulation *tin);$/;"	p	class:ClusterNode	access:public	signature:(MyTriangulation *tin)
ClusterNode::coef1	cluster_node.cpp	/^Coefficient ClusterNode::coef1;$/;"	m	class:ClusterNode	file:
ClusterNode::coef1	cluster_node.h	/^        static Coefficient coef1;$/;"	m	class:ClusterNode	access:public
ClusterNode::coef2	cluster_node.cpp	/^Coefficient ClusterNode::coef2;$/;"	m	class:ClusterNode	file:
ClusterNode::coef2	cluster_node.h	/^        static Coefficient coef2;$/;"	m	class:ClusterNode	access:public
ClusterNode::coef3	cluster_node.cpp	/^Coefficient ClusterNode::coef3;$/;"	m	class:ClusterNode	file:
ClusterNode::coef3	cluster_node.h	/^        static Coefficient coef3;$/;"	m	class:ClusterNode	access:public
ClusterNode::edgeCostFunction	cluster_node.cpp	/^double ClusterNode::edgeCostFunction(const void *cn1, const void *cn2)$/;"	f	class:ClusterNode	signature:(const void *cn1, const void *cn2)
ClusterNode::edgeCostFunction	cluster_node.h	/^        static double edgeCostFunction(const void *n1, const void *n2);$/;"	p	class:ClusterNode	access:public	signature:(const void *n1, const void *n2)
ClusterNode::edgeInfo	cluster_node.cpp	/^std::unordered_set<TrNode,boost::hash<TrNode>> ClusterNode::edgeInfo;$/;"	m	class:ClusterNode	file:
ClusterNode::edgeInfo	cluster_node.h	/^        static std::unordered_set<TrNode,boost::hash<TrNode>> edgeInfo;$/;"	m	class:ClusterNode	access:private
ClusterNode::fittingCylinderCost	cluster_node.cpp	/^double ClusterNode::fittingCylinderCost(const void *cn1, const void *cn2)$/;"	f	class:ClusterNode	signature:(const void *cn1, const void *cn2)
ClusterNode::fittingCylinderCost	cluster_node.h	/^        static double fittingCylinderCost(const void *, const void *);$/;"	p	class:ClusterNode	access:public	signature:(const void *, const void *)
ClusterNode::fittingPlaneCost	cluster_node.cpp	/^double ClusterNode::fittingPlaneCost(const void *cn1, const void *cn2)$/;"	f	class:ClusterNode	signature:(const void *cn1, const void *cn2)
ClusterNode::fittingPlaneCost	cluster_node.h	/^        static double fittingPlaneCost(const void *, const void *);$/;"	p	class:ClusterNode	access:public	signature:(const void *, const void *)
ClusterNode::fittingSphereCost	cluster_node.cpp	/^double ClusterNode::fittingSphereCost(const void *cn1, const void *cn2)$/;"	f	class:ClusterNode	signature:(const void *cn1, const void *cn2)
ClusterNode::fittingSphereCost	cluster_node.h	/^        static double fittingSphereCost(const void *, const void *);$/;"	p	class:ClusterNode	access:public	signature:(const void *, const void *)
ClusterNode::gId2treeId	cluster_node.cpp	/^std::unordered_map<int, int> ClusterNode::gId2treeId;$/;"	m	class:ClusterNode	file:
ClusterNode::gId2treeId	cluster_node.h	/^        static std::unordered_map<int, int> gId2treeId;$/;"	m	class:ClusterNode	access:private
ClusterNode::hierarcStack	cluster_node.h	/^        static std::stack<BinaryTree::NodeId> hierarcStack;$/;"	m	class:ClusterNode	access:public
ClusterNode::hierarchyTree	cluster_node.cpp	/^BinaryTree ClusterNode::hierarchyTree;$/;"	m	class:ClusterNode	file:
ClusterNode::hierarchyTree	cluster_node.h	/^        static BinaryTree hierarchyTree;$/;"	m	class:ClusterNode	access:public
ClusterNode::id	cluster_node.h	/^        int id;                \/\/!< Unique identifier of the node$/;"	m	class:ClusterNode	access:public
ClusterNode::merge	cluster_node.cpp	/^void ClusterNode::merge(const void *n1, const void *n2)$/;"	f	class:ClusterNode	signature:(const void *n1, const void *n2)
ClusterNode::merge	cluster_node.h	/^        static void merge(const void *n1, const void *n2);$/;"	p	class:ClusterNode	access:public	signature:(const void *n1, const void *n2)
ClusterNode::my_fittingCylinderCost	cluster_node.h	/^        static double my_fittingCylinderCost(const void *, const void *);$/;"	p	class:ClusterNode	access:public	signature:(const void *, const void *)
ClusterNode::my_fittingPlaneCost	cluster_node.h	/^        static double my_fittingPlaneCost(const void *, const void *);$/;"	p	class:ClusterNode	access:public	signature:(const void *, const void *)
ClusterNode::my_fittingSphereCost	cluster_node.h	/^        static double my_fittingSphereCost(const void *, const void *);$/;"	p	class:ClusterNode	access:public	signature:(const void *, const void *)
ClusterNode::num_triangles	cluster_node.cpp	/^int ClusterNode::num_triangles = 0;$/;"	m	class:ClusterNode	file:
ClusterNode::num_triangles	cluster_node.h	/^        static int num_triangles;$/;"	m	class:ClusterNode	access:public
ClusterNode::reset	cluster_node.cpp	/^void ClusterNode::reset(){$/;"	f	class:ClusterNode	signature:()
ClusterNode::reset	cluster_node.h	/^        static void reset();$/;"	p	class:ClusterNode	access:public	signature:()
ClusterNode::rootId	cluster_node.cpp	/^BinaryTree::NodeId ClusterNode::rootId;$/;"	m	class:ClusterNode	file:
ClusterNode::rootId	cluster_node.h	/^        static BinaryTree::NodeId rootId;$/;"	m	class:ClusterNode	access:public
ClusterNode::sum_ctr	cluster_node.h	/^        Point sum_ctr;         \/\/!< Weighted sum of barycenters$/;"	m	class:ClusterNode	access:public
ClusterNode::tot_area	cluster_node.h	/^        double tot_area;       \/\/!< Total area of the cluster$/;"	m	class:ClusterNode	access:public
ClusterNode::triangles	cluster_node.h	/^        List triangles;        \/\/!< All the triangles within the cluster$/;"	m	class:ClusterNode	access:public
ClusterNode::weights	cluster_node.cpp	/^BinaryTree::EdgeWeightsMap ClusterNode::weights = hierarchyTree.edge_weights();$/;"	m	class:ClusterNode	file:
ClusterNode::weights	cluster_node.h	/^        static BinaryTree::EdgeWeightsMap weights;$/;"	m	class:ClusterNode	access:private
ClusterNode::~ClusterNode	cluster_node.h	/^        virtual ~ClusterNode() {$/;"	f	class:ClusterNode	access:public	signature:()
Coefficient	cluster_node.h	/^    Coefficient(){ }$/;"	f	struct:Coefficient	access:public	signature:()
Coefficient	cluster_node.h	/^    Coefficient(Point p, Point d, double r):point(p), direction(d), radius(r){ }$/;"	f	struct:Coefficient	access:public	signature:(Point p, Point d, double r)
Coefficient	cluster_node.h	/^struct Coefficient{$/;"	s
Coefficient::Coefficient	cluster_node.h	/^    Coefficient(){ }$/;"	f	struct:Coefficient	access:public	signature:()
Coefficient::Coefficient	cluster_node.h	/^    Coefficient(Point p, Point d, double r):point(p), direction(d), radius(r){ }$/;"	f	struct:Coefficient	access:public	signature:(Point p, Point d, double r)
Coefficient::direction	cluster_node.h	/^    Point direction;                            \/\/!< normal or axis $/;"	m	struct:Coefficient	access:public
Coefficient::point	cluster_node.h	/^    Point point;$/;"	m	struct:Coefficient	access:public
Coefficient::radius	cluster_node.h	/^    double radius;$/;"	m	struct:Coefficient	access:public
Color	component.h	/^        typedef typename Pixel::ColorType Color;$/;"	t	class:Component	access:public
ColorType	pixel.h	/^        typedef GrayColor ColorType;$/;"	t	class:GrayPixel2D	access:public
ColorType	pixel.h	/^        typedef GrayColor ColorType;$/;"	t	class:GrayPixel3D	access:public
ColorType	pixel.h	/^        typedef RgbColor ColorType;$/;"	t	class:RgbPixel2D	access:public
ColorType	pixel.h	/^        typedef RgbColor ColorType;$/;"	t	class:RgbPixel3D	access:public
Component	component.h	/^        Component( ): _max_weight(0), _next(NULL) { }$/;"	f	class:Component	access:public	signature:( )
Component	component.h	/^        Component( const Component &other ):_max_weight(other._max_weight)$/;"	f	class:Component	access:public	signature:( const Component &other )
Component	component.h	/^        Component(T first_pixel): _max_weight(0), _next(NULL) {$/;"	f	class:Component	access:public	signature:(T first_pixel)
Component	component.h	/^class Component {$/;"	c
Component2D	segment2d.h	/^        typedef Component<T*> Component2D;$/;"	t	class:Segment2D	access:public
Component3D	segment3d.h	/^        typedef Component<T*> Component3D;$/;"	t	class:Segment3D	access:public
Component::Color	component.h	/^        typedef typename Pixel::ColorType Color;$/;"	t	class:Component	access:public
Component::Component	component.h	/^        Component( ): _max_weight(0), _next(NULL) { }$/;"	f	class:Component	access:public	signature:( )
Component::Component	component.h	/^        Component( const Component &other ):_max_weight(other._max_weight)$/;"	f	class:Component	access:public	signature:( const Component &other )
Component::Component	component.h	/^        Component(T first_pixel): _max_weight(0), _next(NULL) {$/;"	f	class:Component	access:public	signature:(T first_pixel)
Component::K	component.h	/^        static double K;          \/\/ the larger K, the larger component$/;"	m	class:Component	access:public
Component::K	component.h	/^double Component<T>::K = SCALE;$/;"	m	class:Component
Component::MOVE_NUM	component.h	/^        static double MOVE_NUM;$/;"	m	class:Component	access:public
Component::MOVE_NUM	component.h	/^double Component<T>::MOVE_NUM = 0;$/;"	m	class:Component
Component::Pixel	component.h	/^        typedef typename std::remove_pointer<T>::type Pixel;$/;"	t	class:Component	access:public
Component::_if_merge	component.h	/^        inline static bool _if_merge(double comp_diff, const Component &a, const Component &b) {$/;"	f	class:Component	access:public	signature:(double comp_diff, const Component &a, const Component &b)
Component::_max_weight	component.h	/^        double _max_weight;$/;"	m	class:Component	access:private
Component::_members	component.h	/^        std::set<T> _members;$/;"	m	class:Component	access:private
Component::_next	component.h	/^        Component *_next;$/;"	m	class:Component	access:public
Component::add_member	component.h	/^        inline void add_member(T elem){$/;"	f	class:Component	access:public	signature:(T elem)
Component::clear	component.h	/^        inline void clear(){$/;"	f	class:Component	access:public	signature:()
Component::contains	component.h	/^        inline bool contains(T pixel) const{$/;"	f	class:Component	access:public	signature:(T pixel) const
Component::get_members	component.h	/^        inline const std::set<T>& get_members() const {$/;"	f	class:Component	access:public	signature:() const
Component::get_members	component.h	/^        inline std::set<T>& get_members(){$/;"	f	class:Component	access:public	signature:()
Component::internal_diff	component.h	/^        inline double internal_diff() const{$/;"	f	class:Component	access:public	signature:() const
Component::merge	component.h	/^         inline static int merge(double component_diff,   Component &s, Component &t){$/;"	f	class:Component	access:public	signature:(double component_diff, Component &s, Component &t)
Component::merge_from	component.h	/^        inline void merge_from(const Component &r){$/;"	f	class:Component	access:public	signature:(const Component &r)
Component::operator <	component.h	/^        inline bool operator < (const Component &r) const{$/;"	f	class:Component	access:public	signature:(const Component &r) const
Component::right_one	component.h	/^        inline Component* right_one(){$/;"	f	class:Component	access:public	signature:()
Component::set_max_weight	component.h	/^        inline void set_max_weight(double w){$/;"	f	class:Component	access:public	signature:(double w)
Component::size	component.h	/^        inline int size() const{$/;"	f	class:Component	access:public	signature:() const
ComponentsInfo	triangulate.h	/^    ComponentsInfo(){$/;"	f	struct:ComponentsInfo	access:public	signature:()
ComponentsInfo	triangulate.h	/^struct ComponentsInfo{$/;"	s
ComponentsInfo::ComponentsInfo	triangulate.h	/^    ComponentsInfo(){$/;"	f	struct:ComponentsInfo	access:public	signature:()
ComponentsInfo::_color	triangulate.h	/^    m_opencv::RgbColor _color;$/;"	m	struct:ComponentsInfo	access:public
ComponentsInfo::_leafs	triangulate.h	/^    std::vector<BinaryTree::NodeId> _leafs;$/;"	m	struct:ComponentsInfo	access:public
ComponentsInfo::_num_components	triangulate.h	/^    int _num_components;$/;"	m	struct:ComponentsInfo	access:public
ComponentsInfo::clear	triangulate.h	/^    void clear(){$/;"	f	struct:ComponentsInfo	access:public	signature:()
ConstEdgeWeightsMap	graph.h	/^        typedef typename property_map<GraphContainer, boost::edge_weight_t>::const_type ConstEdgeWeightsMap;$/;"	t	class:m_graph::BaseGraph	access:public
Cov_c	cluster_node.h	/^        SymMatrix3x3 Cov_c;    \/\/!< Covariance matrix of normal variation$/;"	m	class:ClusterNode	access:public
Cov_v	cluster_node.h	/^        SymMatrix3x3 Cov_v;    \/\/!< Covariance matrix of cluster vertices$/;"	m	class:ClusterNode	access:public
DEBUG_LEVEL	emd.cpp	27;"	d	file:
DegreeSize	graph.h	/^        typedef typename BaseGraph<GraphContainer>::DegreeSize DegreeSize;$/;"	t	class:m_graph::AutoUniGraph	access:public
DegreeSize	graph.h	/^        typedef typename BaseGraph<GraphContainer>::DegreeSize DegreeSize;$/;"	t	class:m_graph::ManualUniGraph	access:public
DegreeSize	graph.h	/^        typedef typename graph_traits<GraphContainer>::degree_size_type DegreeSize;$/;"	t	class:m_graph::BaseGraph	access:public
EPSILON	emd.h	23;"	d
EdgeId	graph.h	/^        typedef typename BaseGraph<GraphContainer>::EdgeId EdgeId;$/;"	t	class:m_graph::AutoUniGraph	access:public
EdgeId	graph.h	/^        typedef typename BaseGraph<GraphContainer>::EdgeId EdgeId;$/;"	t	class:m_graph::ManualUniGraph	access:public
EdgeId	graph.h	/^        typedef typename graph_traits<GraphContainer>::edge_descriptor EdgeId;$/;"	t	class:m_graph::BaseGraph	access:public
EdgeIter	graph.h	/^        typedef typename BaseGraph<GraphContainer>::EdgeIter EdgeIter;$/;"	t	class:m_graph::AutoUniGraph	access:public
EdgeIter	graph.h	/^        typedef typename BaseGraph<GraphContainer>::EdgeIter EdgeIter;$/;"	t	class:m_graph::ManualUniGraph	access:public
EdgeIter	graph.h	/^        typedef typename graph_traits<GraphContainer>::edge_iterator EdgeIter;$/;"	t	class:m_graph::BaseGraph	access:public
EdgePair	graph.h	/^        typedef std::pair<NodeId, NodeId> EdgePair;$/;"	t	class:m_graph::AutoUniGraph	access:public
EdgePair	graph.h	/^        typedef std::pair<NodeId, NodeId> EdgePair;$/;"	t	class:m_graph::BaseGraph	access:public
EdgePair	graph.h	/^        typedef std::pair<NodeId, NodeId> EdgePair;$/;"	t	class:m_graph::ManualUniGraph	access:public
EdgeRange	graph.h	/^        typedef std::pair<EdgeIter, EdgeIter> EdgeRange;$/;"	t	class:m_graph::AutoUniGraph	access:public
EdgeRange	graph.h	/^        typedef std::pair<EdgeIter, EdgeIter> EdgeRange;$/;"	t	class:m_graph::BaseGraph	access:public
EdgeRange	graph.h	/^        typedef std::pair<EdgeIter, EdgeIter> EdgeRange;$/;"	t	class:m_graph::ManualUniGraph	access:public
EdgeWeightsMap	graph.h	/^        typedef typename BaseGraph<GraphContainer>::EdgeWeightsMap EdgeWeightsMap;$/;"	t	class:m_graph::AutoUniGraph	access:public
EdgeWeightsMap	graph.h	/^        typedef typename BaseGraph<GraphContainer>::EdgeWeightsMap EdgeWeightsMap;$/;"	t	class:m_graph::ManualUniGraph	access:public
EdgeWeightsMap	graph.h	/^        typedef typename property_map<GraphContainer, boost::edge_weight_t>::type EdgeWeightsMap;$/;"	t	class:m_graph::BaseGraph	access:public
FITTING_PRIMITIVES_H	cluster_node.h	3;"	d
Features	emd.h	/^  feature_t *Features;  \/* Pointer to the features vector *\/$/;"	m	struct:__anon1	access:public
Features	emd.h	/^typedef std::vector<feature_t, Eigen::aligned_allocator<pcl::PointXYZRGB>> Features;$/;"	t
Filter	segment2d.h	/^            Filter(int n = 1):_scale(n){ }$/;"	f	struct:Segment2D::Filter	access:public	signature:(int n = 1)
Filter	segment2d.h	/^        struct Filter : public unary_function<Component2D, bool> {$/;"	s	class:Segment2D	inherits:unary_function	access:public
FindComponents	triangulate.h	/^        FindComponents(ComponentsInfo *c, BinaryTree *tr):_compInfo(c),_btree(tr){ }$/;"	f	class:FindComponents	access:public	signature:(ComponentsInfo *c, BinaryTree *tr)
FindComponents	triangulate.h	/^class FindComponents : public boost::default_bfs_visitor$/;"	c	inherits:boost::default_bfs_visitor
FindComponents::FindComponents	triangulate.h	/^        FindComponents(ComponentsInfo *c, BinaryTree *tr):_compInfo(c),_btree(tr){ }$/;"	f	class:FindComponents	access:public	signature:(ComponentsInfo *c, BinaryTree *tr)
FindComponents::_btree	triangulate.h	/^        BinaryTree *_btree;$/;"	m	class:FindComponents	access:public
FindComponents::_compInfo	triangulate.h	/^        ComponentsInfo *_compInfo;$/;"	m	class:FindComponents	access:public
FindComponents::discover_vertex	triangulate.h	/^            void discover_vertex(Vertex u, const Graph & g)$/;"	f	class:FindComponents	access:public	signature:(Vertex u, const Graph & g)
GRAPH_H	graph.h	10;"	d
GraphUtil	graph.h	/^    GraphUtil (Graph *graph):_g(graph){$/;"	f	class:m_graph::GraphUtil	access:public	signature:(Graph *graph)
GraphUtil	graph.h	/^class GraphUtil {$/;"	c	namespace:m_graph
GrayPixel2D	pixel.h	/^        GrayPixel2D(int x = 0 , int y = 0, Component<GrayPixel2D*> *parent = NULL)$/;"	f	class:GrayPixel2D	access:public	signature:(int x = 0 , int y = 0, Component<GrayPixel2D*> *parent = NULL)
GrayPixel2D	pixel.h	/^class GrayPixel2D{$/;"	c
GrayPixel2D::CHANELS	pixel.h	/^        static const int CHANELS = 1;$/;"	m	class:GrayPixel2D	access:public
GrayPixel2D::ColorType	pixel.h	/^        typedef GrayColor ColorType;$/;"	t	class:GrayPixel2D	access:public
GrayPixel2D::GrayPixel2D	pixel.h	/^        GrayPixel2D(int x = 0 , int y = 0, Component<GrayPixel2D*> *parent = NULL)$/;"	f	class:GrayPixel2D	access:public	signature:(int x = 0 , int y = 0, Component<GrayPixel2D*> *parent = NULL)
GrayPixel2D::ISRGB	pixel.h	/^        static const bool ISRGB = false;$/;"	m	class:GrayPixel2D	access:public
GrayPixel2D::ImageType	pixel.h	/^        typedef GrayImage ImageType;$/;"	t	class:GrayPixel2D	access:public
GrayPixel2D::MeasureColorType	pixel.h	/^        typedef GrayColor MeasureColorType;$/;"	t	class:GrayPixel2D	access:public
GrayPixel2D::_color	pixel.h	/^        GrayColor _color;$/;"	m	class:GrayPixel2D	access:public
GrayPixel2D::_parent	pixel.h	/^        Component<GrayPixel2D*> *_parent;$/;"	m	class:GrayPixel2D	access:public
GrayPixel2D::_x	pixel.h	/^        int _x;$/;"	m	class:GrayPixel2D	access:public
GrayPixel2D::_y	pixel.h	/^        int _y;$/;"	m	class:GrayPixel2D	access:public
GrayPixel2D::density_distance	pixel.h	/^        static double density_distance(const GrayPixel2D &a, const GrayPixel2D &b){$/;"	f	class:GrayPixel2D	access:public	signature:(const GrayPixel2D &a, const GrayPixel2D &b)
GrayPixel2D::get_color	pixel.h	/^        const GrayColor&  get_color() const{$/;"	f	class:GrayPixel2D	access:public	signature:() const
GrayPixel2D::get_density	pixel.h	/^        double get_density() const{$/;"	f	class:GrayPixel2D	access:public	signature:() const
GrayPixel2D::get_measure_color	pixel.h	/^        const GrayColor&  get_measure_color() const{$/;"	f	class:GrayPixel2D	access:public	signature:() const
GrayPixel2D::operator <	pixel.h	/^        bool operator < (const GrayPixel2D &other) const{$/;"	f	class:GrayPixel2D	access:public	signature:(const GrayPixel2D &other) const
GrayPixel2D::set_color	pixel.h	/^        void set_color(const GrayColor &gray){$/;"	f	class:GrayPixel2D	access:public	signature:(const GrayColor &gray)
GrayPixel2D::set_location	pixel.h	/^        void set_location(int x, int y){$/;"	f	class:GrayPixel2D	access:public	signature:(int x, int y)
GrayPixel2D::spatial_distance	pixel.h	/^        static double spatial_distance(const GrayPixel2D &a, const GrayPixel2D &b){$/;"	f	class:GrayPixel2D	access:public	signature:(const GrayPixel2D &a, const GrayPixel2D &b)
GrayPixel2D::white_color	pixel.h	/^        static GrayColor white_color(){$/;"	f	class:GrayPixel2D	access:public	signature:()
GrayPixel3D	pixel.h	/^        GrayPixel3D(const GrayColor &color, float x = 0 , float y = 0, float z = 0, int size = 0):_x(x), _y(y), _z(z),$/;"	f	class:GrayPixel3D	access:public	signature:(const GrayColor &color, float x = 0 , float y = 0, float z = 0, int size = 0)
GrayPixel3D	pixel.h	/^        GrayPixel3D(float x = 0, float y = 0, float z = 0, Component<GrayPixel3D*> *parent = NULL)$/;"	f	class:GrayPixel3D	access:public	signature:(float x = 0, float y = 0, float z = 0, Component<GrayPixel3D*> *parent = NULL)
GrayPixel3D	pixel.h	/^class GrayPixel3D{$/;"	c
GrayPixel3D::ColorType	pixel.h	/^        typedef GrayColor ColorType;$/;"	t	class:GrayPixel3D	access:public
GrayPixel3D::GrayPixel3D	pixel.h	/^        GrayPixel3D(const GrayColor &color, float x = 0 , float y = 0, float z = 0, int size = 0):_x(x), _y(y), _z(z),$/;"	f	class:GrayPixel3D	access:public	signature:(const GrayColor &color, float x = 0 , float y = 0, float z = 0, int size = 0)
GrayPixel3D::GrayPixel3D	pixel.h	/^        GrayPixel3D(float x = 0, float y = 0, float z = 0, Component<GrayPixel3D*> *parent = NULL)$/;"	f	class:GrayPixel3D	access:public	signature:(float x = 0, float y = 0, float z = 0, Component<GrayPixel3D*> *parent = NULL)
GrayPixel3D::MeasureColorType	pixel.h	/^        typedef GrayColor MeasureColorType;$/;"	t	class:GrayPixel3D	access:public
GrayPixel3D::_color	pixel.h	/^        GrayColor _color;$/;"	m	class:GrayPixel3D	access:protected
GrayPixel3D::_parent	pixel.h	/^        Component<GrayPixel3D*> *_parent;$/;"	m	class:GrayPixel3D	access:public
GrayPixel3D::_size	pixel.h	/^        int _size;$/;"	m	class:GrayPixel3D	access:public
GrayPixel3D::_x	pixel.h	/^        float _x;$/;"	m	class:GrayPixel3D	access:public
GrayPixel3D::_y	pixel.h	/^        float _y;$/;"	m	class:GrayPixel3D	access:public
GrayPixel3D::_z	pixel.h	/^        float _z;$/;"	m	class:GrayPixel3D	access:public
GrayPixel3D::density_distance	pixel.h	/^        static double density_distance(const GrayPixel3D &a, const GrayPixel3D &b){$/;"	f	class:GrayPixel3D	access:public	signature:(const GrayPixel3D &a, const GrayPixel3D &b)
GrayPixel3D::get_color	pixel.h	/^        GrayColor  get_color() const{$/;"	f	class:GrayPixel3D	access:public	signature:() const
GrayPixel3D::get_density	pixel.h	/^        double get_density() const{$/;"	f	class:GrayPixel3D	access:public	signature:() const
GrayPixel3D::get_measure_color	pixel.h	/^        const GrayColor& get_measure_color()const {$/;"	f	class:GrayPixel3D	access:public	signature:() const
GrayPixel3D::operator <	pixel.h	/^        bool operator < (const GrayPixel3D &other) const{$/;"	f	class:GrayPixel3D	access:public	signature:(const GrayPixel3D &other) const
GrayPixel3D::set_color	pixel.h	/^        void set_color(const GrayColor &gray){$/;"	f	class:GrayPixel3D	access:public	signature:(const GrayColor &gray)
GrayPixel3D::set_location	pixel.h	/^        void set_location(float x, float y, float z){$/;"	f	class:GrayPixel3D	access:public	signature:(float x, float y, float z)
GrayPixel3D::spatial_distance	pixel.h	/^        static double spatial_distance(const GrayPixel3D &a, const GrayPixel3D &b){$/;"	f	class:GrayPixel3D	access:public	signature:(const GrayPixel3D &a, const GrayPixel3D &b)
HFP_FIT_CYLINDERS	cluster_node.h	27;"	d
HFP_FIT_PLANES	cluster_node.h	25;"	d
HFP_FIT_SPHERES	cluster_node.h	26;"	d
HieraTree	cluster_node.h	/^typedef m_graph::AutoUniGraph<boostGraph, TrNode> HieraTree;$/;"	t
INFINITY	emd.h	22;"	d
ISRGB	pixel.h	/^        static const bool ISRGB = false;$/;"	m	class:GrayPixel2D	access:public
ISRGB	pixel.h	/^        static const bool ISRGB = true;$/;"	m	class:RgbPixel2D	access:public
ImageModel	segment2d.h	/^        typedef m_graph::VizGraph<Region2D, int> ImageModel;$/;"	t	class:Segment2D	access:public
ImageModel	segment3d.h	/^        typedef m_graph::VizGraph<Region3D, int> ImageModel;$/;"	t	class:Segment3D	access:public
ImageModel	segment3d.h	/^        typedef m_graph::VizGraph<Region3D_<T>, int> ImageModel;$/;"	t	class:SegMethod	access:public
ImageType	pixel.h	/^        typedef GrayImage ImageType;$/;"	t	class:GrayPixel2D	access:public
ImageType	pixel.h	/^        typedef RgbImage ImageType;$/;"	t	class:RgbPixel2D	access:public
InEdgeIter	graph.h	/^        typedef typename BaseGraph<GraphContainer>::InEdgeIter InEdgeIter;$/;"	t	class:m_graph::AutoUniGraph	access:public
InEdgeIter	graph.h	/^        typedef typename BaseGraph<GraphContainer>::InEdgeIter InEdgeIter;$/;"	t	class:m_graph::ManualUniGraph	access:public
InEdgeIter	graph.h	/^        typedef typename graph_traits<GraphContainer>::in_edge_iterator InEdgeIter;$/;"	t	class:m_graph::BaseGraph	access:public
InEdgeRange	graph.h	/^        typedef std::pair<InEdgeIter, InEdgeIter> InEdgeRange;$/;"	t	class:m_graph::AutoUniGraph	access:public
InEdgeRange	graph.h	/^        typedef std::pair<InEdgeIter, InEdgeIter> InEdgeRange;$/;"	t	class:m_graph::BaseGraph	access:public
InEdgeRange	graph.h	/^        typedef std::pair<InEdgeIter, InEdgeIter> InEdgeRange;$/;"	t	class:m_graph::ManualUniGraph	access:public
IterativeClosestPoint	icp.h	/^      IterativeClosestPoint () $/;"	f	class:IterativeClosestPoint	access:public	signature:()
IterativeClosestPoint	icp.h	/^  class IterativeClosestPoint : public Registration<PointSource, PointTarget>$/;"	c	inherits:Registration
IterativeClosestPoint::BiMap	icp.h	/^    typedef boost::bimaps::bimap< int, int > BiMap;$/;"	t	class:IterativeClosestPoint	access:private
IterativeClosestPoint::BiValue	icp.h	/^    typedef BiMap::value_type BiValue;$/;"	t	class:IterativeClosestPoint	access:private
IterativeClosestPoint::IterativeClosestPoint	icp.h	/^      IterativeClosestPoint () $/;"	f	class:IterativeClosestPoint	access:public	signature:()
IterativeClosestPoint::PointCloudSource	icp.h	/^    typedef typename Registration<PointSource, PointTarget>::PointCloudSource PointCloudSource;$/;"	t	class:IterativeClosestPoint	access:private
IterativeClosestPoint::PointCloudSourceConstPtr	icp.h	/^    typedef typename PointCloudSource::ConstPtr PointCloudSourceConstPtr;$/;"	t	class:IterativeClosestPoint	access:private
IterativeClosestPoint::PointCloudSourcePtr	icp.h	/^    typedef typename PointCloudSource::Ptr PointCloudSourcePtr;$/;"	t	class:IterativeClosestPoint	access:private
IterativeClosestPoint::PointCloudTarget	icp.h	/^    typedef typename Registration<PointSource, PointTarget>::PointCloudTarget PointCloudTarget;$/;"	t	class:IterativeClosestPoint	access:private
IterativeClosestPoint::PointIndicesConstPtr	icp.h	/^    typedef PointIndices::ConstPtr PointIndicesConstPtr;$/;"	t	class:IterativeClosestPoint	access:private
IterativeClosestPoint::PointIndicesPtr	icp.h	/^    typedef PointIndices::Ptr PointIndicesPtr;$/;"	t	class:IterativeClosestPoint	access:private
IterativeClosestPoint::computeTransformation	icp.h	/^      computeTransformation (PointCloudSource &output, const Eigen::Matrix4f &guess);$/;"	p	class:IterativeClosestPoint	access:protected	signature:(PointCloudSource &output, const Eigen::Matrix4f &guess)
IterativeClosestPoint::get_correspondence	icp.h	/^      const BiMap& get_correspondence() const{$/;"	f	class:IterativeClosestPoint	access:public	signature:() const
IterativeClosestPoint::myCorrespondence_	icp.h	/^      BiMap myCorrespondence_;$/;"	m	class:IterativeClosestPoint	access:protected
IterativeClosestPoint::output_	icp.h	/^      PointCloudSource *output_;$/;"	m	class:IterativeClosestPoint	access:protected
IterativeClosestPoint::previousEMD_	icp.h	/^      float previousEMD_;$/;"	m	class:IterativeClosestPoint	access:protected
IterativeClosestPoint::setInputWeight	icp.h	/^      void setInputWeight(const std::vector<float> &wInput);$/;"	p	class:IterativeClosestPoint	access:public	signature:(const std::vector<float> &wInput)
IterativeClosestPoint::setOutputWeight	icp.h	/^      void setOutputWeight(const std::vector<float> &wOutput);$/;"	p	class:IterativeClosestPoint	access:public	signature:(const std::vector<float> &wOutput)
IterativeClosestPoint::visualize_correspondence	icp.h	/^      void visualize_correspondence(VizBlockWorld *viz, int view) const;$/;"	p	class:IterativeClosestPoint	access:public	signature:(VizBlockWorld *viz, int view) const
IterativeClosestPoint::wOutput_	icp.h	/^      std::vector<float> wOutput_;$/;"	m	class:IterativeClosestPoint	access:protected
K	component.h	/^        static double K;          \/\/ the larger K, the larger component$/;"	m	class:Component	access:public
K	component.h	/^double Component<T>::K = SCALE;$/;"	m	class:Component
LOWER_BOUND	cluster_node.cpp	/^const int LOWER_BOUND = 100;                     \/\/!< the minmum number one component have $/;"	v
MAX_ITERATIONS	emd.h	21;"	d
MAX_SIG_SIZE	emd.h	20;"	d
MAX_SIG_SIZE1	emd.cpp	38;"	d	file:
MOVE_NUM	component.h	/^        static double MOVE_NUM;$/;"	m	class:Component	access:public
MOVE_NUM	component.h	/^double Component<T>::MOVE_NUM = 0;$/;"	m	class:Component
ManualUniGraph	graph.h	/^        ManualUniGraph (){ $/;"	f	class:m_graph::ManualUniGraph	access:public	signature:()
ManualUniGraph	graph.h	/^        ManualUniGraph (int numNode):BaseGraph<GraphContainer>(numNode){ $/;"	f	class:m_graph::ManualUniGraph	access:public	signature:(int numNode)
ManualUniGraph	graph.h	/^class ManualUniGraph :public BaseGraph<GraphContainer>{$/;"	c	namespace:m_graph	inherits:BaseGraph
MatrixGraph	graph.cpp	/^    typedef std::vector< std::vector<int> > MatrixGraph;$/;"	t	file:
MatrixGraph	graph.h	/^    typedef std::vector< std::vector<int> > MatrixGraph;$/;"	t	namespace:m_graph
MatrixGraph	graph.h	/^typedef std::vector<std::vector<int> > MatrixGraph;$/;"	t	namespace:m_graph
MeasureColorType	pixel.h	/^        typedef GrayColor MeasureColorType;$/;"	t	class:GrayPixel2D	access:public
MeasureColorType	pixel.h	/^        typedef GrayColor MeasureColorType;$/;"	t	class:GrayPixel3D	access:public
MeasureColorType	pixel.h	/^        typedef LuvColor MeasureColorType;$/;"	t	class:RgbPixel2D	access:public
MeasureColorType	pixel.h	/^        typedef LuvColor MeasureColorType;$/;"	t	class:RgbPixel3D	access:public
MyTriangulation	triangulate.h	/^        MyTriangulation (VizBlockWorld *viz):_viz(viz), _s(false), _colorGenerator(50){ }$/;"	f	class:MyTriangulation	access:public	signature:(VizBlockWorld *viz)
MyTriangulation	triangulate.h	/^class MyTriangulation :public Triangulation{$/;"	c	inherits:Triangulation
MyTriangulation::MyTriangulation	triangulate.h	/^        MyTriangulation (VizBlockWorld *viz):_viz(viz), _s(false), _colorGenerator(50){ }$/;"	f	class:MyTriangulation	access:public	signature:(VizBlockWorld *viz)
MyTriangulation::TopoGraph	triangulate.h	/^        typedef m_graph::AutoUniGraph<boostGraph2, TrNode> TopoGraph;$/;"	t	class:MyTriangulation	access:protected
MyTriangulation::_colorGenerator	triangulate.h	/^        m_opencv::RandomColor _colorGenerator;$/;"	m	class:MyTriangulation	access:private
MyTriangulation::_s	triangulate.h	/^        bool _s;$/;"	m	class:MyTriangulation	access:private
MyTriangulation::_viz	triangulate.h	/^        VizBlockWorld *_viz;$/;"	m	class:MyTriangulation	access:private
MyTriangulation::_vizIds	triangulate.h	/^        std::stack<std::string> _vizIds; \/\/!< store id of components in visualizer$/;"	m	class:MyTriangulation	access:private
MyTriangulation::boostGraph2	triangulate.h	/^        typedef adjacency_list<vecS, vecS, undirectedS, no_property, property<edge_weight_t, int> > boostGraph2;$/;"	t	class:MyTriangulation	access:protected
MyTriangulation::change_color	triangulate.cpp	/^void MyTriangulation::change_color(){$/;"	f	class:MyTriangulation	signature:()
MyTriangulation::change_color	triangulate.h	/^        void change_color();$/;"	p	class:MyTriangulation	access:public	signature:()
MyTriangulation::dynamic_EMD	triangulate.cpp	/^MyTriangulation::dynamic_EMD(PointCloudPtr target, PointCloudPtr source,$/;"	f	class:MyTriangulation	signature:(PointCloudPtr target, PointCloudPtr source, const vector<float> &wInput, const vector<float> &wOutput)
MyTriangulation::dynamic_EMD	triangulate.h	/^        void dynamic_EMD(PointCloudPtr target, PointCloudPtr source,$/;"	p	class:MyTriangulation	access:public	signature:(PointCloudPtr target, PointCloudPtr source, const vector<float> &wInput, const vector<float> &wOutput)
MyTriangulation::load_mesh	triangulate.cpp	/^int MyTriangulation::load_mesh(const pcl::PointCloud<pcl::PointXYZ>::Ptr cloud, const pcl::PolygonMesh &meshes){$/;"	f	class:MyTriangulation	signature:(const pcl::PointCloud<pcl::PointXYZ>::Ptr cloud, const pcl::PolygonMesh &meshes)
MyTriangulation::load_mesh	triangulate.h	/^        int load_mesh(const pcl::PointCloud<pcl::PointXYZ>::Ptr cloud, const pcl::PolygonMesh &meshes);$/;"	p	class:MyTriangulation	access:protected	signature:(const pcl::PointCloud<pcl::PointXYZ>::Ptr cloud, const pcl::PolygonMesh &meshes)
MyTriangulation::pos_MDS	triangulate.cpp	/^MyTriangulation::pos_MDS(PointCloudPtr posNodes, const MatrixGraph &dstMatrix){$/;"	f	class:MyTriangulation	signature:(PointCloudPtr posNodes, const MatrixGraph &dstMatrix)
MyTriangulation::pos_MDS	triangulate.h	/^        void pos_MDS(PointCloudPtr posNodes, const MatrixGraph &dstMatrix);$/;"	p	class:MyTriangulation	access:protected	signature:(PointCloudPtr posNodes, const MatrixGraph &dstMatrix)
MyTriangulation::pos_and_weight	triangulate.cpp	/^void MyTriangulation::pos_and_weight(const std::string &fname,$/;"	f	class:MyTriangulation	signature:(const std::string &fname, PointCloudPtr posNodes, vector<float> *wNodes)
MyTriangulation::pos_and_weight	triangulate.h	/^        void pos_and_weight(const std::string &fname,$/;"	p	class:MyTriangulation	access:public	signature:(const std::string &fname, PointCloudPtr posNodes, vector<float> *wNodes)
MyTriangulation::prepare4segmentation	triangulate.h	/^        inline void prepare4segmentation()const{$/;"	f	class:MyTriangulation	access:protected	signature:() const
MyTriangulation::segment_points	triangulate.cpp	/^void MyTriangulation::segment_points(const pcl::PointCloud<pcl::PointXYZ>::Ptr points){$/;"	f	class:MyTriangulation	signature:(const pcl::PointCloud<pcl::PointXYZ>::Ptr points)
MyTriangulation::segment_points	triangulate.h	/^        void segment_points(const pcl::PointCloud<pcl::PointXYZ>::Ptr points);$/;"	p	class:MyTriangulation	access:public	signature:(const pcl::PointCloud<pcl::PointXYZ>::Ptr points)
MyTriangulation::triangles_of_component	triangulate.cpp	/^void MyTriangulation::triangles_of_component(int root, std::vector<Triangle*> *triangles)const{$/;"	f	class:MyTriangulation	signature:(int root, std::vector<Triangle*> *triangles) const
MyTriangulation::triangles_of_component	triangulate.h	/^        void triangles_of_component(int root, std::vector<Triangle*> *t)const;$/;"	p	class:MyTriangulation	access:public	signature:(int root, std::vector<Triangle*> *t) const
MyTriangulation::unweighted_graphmodel	triangulate.cpp	/^void MyTriangulation::unweighted_graphmodel(BinaryTree *tree){$/;"	f	class:MyTriangulation	signature:(BinaryTree *tree)
MyTriangulation::unweighted_graphmodel	triangulate.h	/^        void unweighted_graphmodel(BinaryTree *tree);$/;"	p	class:MyTriangulation	access:protected	signature:(BinaryTree *tree)
MyTriangulation::viz_component	triangulate.cpp	/^std::string MyTriangulation::viz_component(const std::vector<Triangle*> &triangles, const RgbColor &color)const{$/;"	f	class:MyTriangulation	signature:(const std::vector<Triangle*> &triangles, const RgbColor &color) const
MyTriangulation::viz_component	triangulate.h	/^        std::string viz_component(const std::vector<Triangle*> &triangles,$/;"	p	class:MyTriangulation	access:public	signature:(const std::vector<Triangle*> &triangles, const m_opencv::RgbColor &color) const
MyTriangulation::viz_next_level	triangulate.cpp	/^void MyTriangulation::viz_next_level(){$/;"	f	class:MyTriangulation	signature:()
MyTriangulation::viz_next_level	triangulate.h	/^        void viz_next_level();$/;"	p	class:MyTriangulation	access:public	signature:()
MyTriangulation::viz_previous_level	triangulate.cpp	/^void MyTriangulation::viz_previous_level(){$/;"	f	class:MyTriangulation	signature:()
MyTriangulation::viz_previous_level	triangulate.h	/^        void viz_previous_level();$/;"	p	class:MyTriangulation	access:public	signature:()
MyTriangulation::~MyTriangulation	triangulate.h	/^        virtual ~MyTriangulation (){ };$/;"	f	class:MyTriangulation	access:public	signature:()
Next	emd.cpp	/^    struct node1_t *Next;$/;"	m	struct:node1_t	typeref:struct:node1_t::node1_t	file:	access:public
NextC	emd.cpp	/^    struct node2_t *NextC;               \/* NEXT COLUMN *\/$/;"	m	struct:node2_t	typeref:struct:node2_t::node2_t	file:	access:public
NextR	emd.cpp	/^    struct node2_t *NextR;               \/* NEXT ROW *\/$/;"	m	struct:node2_t	typeref:struct:node2_t::node2_t	file:	access:public
NodeId	cluster_node.h	/^        typedef HieraTree::NodeId NodeId;$/;"	t	class:BinaryTree	access:public
NodeId	graph.h	/^        typedef typename BaseGraph<GraphContainer>::NodeId NodeId;$/;"	t	class:m_graph::AutoUniGraph	access:public
NodeId	graph.h	/^        typedef typename BaseGraph<GraphContainer>::NodeId NodeId;$/;"	t	class:m_graph::ManualUniGraph	access:public
NodeId	graph.h	/^        typedef typename graph_traits<GraphContainer>::vertex_descriptor NodeId;$/;"	t	class:m_graph::BaseGraph	access:public
NodeIter	graph.h	/^        typedef typename BaseGraph<GraphContainer>::NodeIter NodeIter;$/;"	t	class:m_graph::AutoUniGraph	access:public
NodeIter	graph.h	/^        typedef typename BaseGraph<GraphContainer>::NodeIter NodeIter;$/;"	t	class:m_graph::ManualUniGraph	access:public
NodeIter	graph.h	/^        typedef typename graph_traits<GraphContainer>::vertex_iterator NodeIter;$/;"	t	class:m_graph::BaseGraph	access:public
NodeRange	graph.h	/^        typedef std::pair<NodeIter, NodeIter> NodeRange;$/;"	t	class:m_graph::AutoUniGraph	access:public
NodeRange	graph.h	/^        typedef std::pair<NodeIter, NodeIter> NodeRange;$/;"	t	class:m_graph::BaseGraph	access:public
NodeRange	graph.h	/^        typedef std::pair<NodeIter, NodeIter> NodeRange;$/;"	t	class:m_graph::ManualUniGraph	access:public
NodeType	graph.h	/^        typedef Node NodeType;$/;"	t	class:m_graph::AutoUniGraph	access:public
NodeType	graph.h	/^        typedef Node NodeType;$/;"	t	class:m_graph::ManualUniGraph	access:public
NodesMap	graph.h	/^        typedef typename property_map<GraphContainer, vertex_node_t>::type NodesMap;$/;"	t	class:m_graph::ManualUniGraph	access:public
OriginMethod	util.h	/^        OriginMethod(const std::set<T> &pixels):_pixels(pixels){ $/;"	f	class:OriginMethod	access:public	signature:(const std::set<T> &pixels)
OriginMethod	util.h	/^class OriginMethod: public xmlrpc_c::method {$/;"	c	inherits:xmlrpc_c::method
OriginMethod::OriginMethod	util.h	/^        OriginMethod(const std::set<T> &pixels):_pixels(pixels){ $/;"	f	class:OriginMethod	access:public	signature:(const std::set<T> &pixels)
OriginMethod::_pixels	util.h	/^        const std::set<T> &_pixels;$/;"	m	class:OriginMethod	access:private
OriginMethod::_rst	util.h	/^        xmlrpc_c::value _rst;$/;"	m	class:OriginMethod	access:private
OriginMethod::execute	util.h	/^        void execute(xmlrpc_c::paramList const& paramList,$/;"	f	class:OriginMethod	access:public	signature:(xmlrpc_c::paramList const& paramList, xmlrpc_c::value * const retvalP)
OutEdgeIter	graph.h	/^        typedef typename BaseGraph<GraphContainer>::OutEdgeIter OutEdgeIter;$/;"	t	class:m_graph::AutoUniGraph	access:public
OutEdgeIter	graph.h	/^        typedef typename BaseGraph<GraphContainer>::OutEdgeIter OutEdgeIter;$/;"	t	class:m_graph::ManualUniGraph	access:public
OutEdgeIter	graph.h	/^        typedef typename graph_traits<GraphContainer>::out_edge_iterator OutEdgeIter;$/;"	t	class:m_graph::BaseGraph	access:public
OutEdgeRange	graph.h	/^        typedef std::pair<OutEdgeIter, OutEdgeIter> OutEdgeRange;$/;"	t	class:m_graph::AutoUniGraph	access:public
OutEdgeRange	graph.h	/^        typedef std::pair<OutEdgeIter, OutEdgeIter> OutEdgeRange;$/;"	t	class:m_graph::BaseGraph	access:public
OutEdgeRange	graph.h	/^        typedef std::pair<OutEdgeIter, OutEdgeIter> OutEdgeRange;$/;"	t	class:m_graph::ManualUniGraph	access:public
PCL_ICP_H_	icp.h	39;"	d
PIXELWORLD2D_H	pixelworld2d.h	9;"	d
PIXELWORLD3D_H	pixelworld3d.h	9;"	d
PIXEL_H	pixel.h	11;"	d
Pixel	component.h	/^        typedef typename std::remove_pointer<T>::type Pixel;$/;"	t	class:Component	access:public
PixelSet	pixelworld3d.h	/^        typedef std::set<T> PixelSet;$/;"	t	class:PixelWorld3D	access:public
PixelSet	segment3d.h	/^        typedef typename PixelWorld3D<T>::PixelSet PixelSet;$/;"	t	class:Segment3D	access:public
PixelWorld2D	pixelworld2d.h	/^        PixelWorld2D (std::string filename = "");$/;"	p	class:PixelWorld2D	access:public	signature:(std::string filename = Ó)
PixelWorld2D	pixelworld2d.h	/^PixelWorld2D<T>::PixelWorld2D(std::string filename):_image(NULL)$/;"	f	class:PixelWorld2D	signature:(std::string filename)
PixelWorld2D	pixelworld2d.h	/^class PixelWorld2D {$/;"	c
PixelWorld2D::PixelWorld2D	pixelworld2d.h	/^        PixelWorld2D (std::string filename = "");$/;"	p	class:PixelWorld2D	access:public	signature:(std::string filename = Ó)
PixelWorld2D::PixelWorld2D	pixelworld2d.h	/^PixelWorld2D<T>::PixelWorld2D(std::string filename):_image(NULL)$/;"	f	class:PixelWorld2D	signature:(std::string filename)
PixelWorld2D::_height	pixelworld2d.h	/^        int             _height;$/;"	m	class:PixelWorld2D	access:protected
PixelWorld2D::_image	pixelworld2d.h	/^        typename T::ImageType _image;$/;"	m	class:PixelWorld2D	access:protected
PixelWorld2D::_pixels	pixelworld2d.h	/^        T        **_pixels;    $/;"	m	class:PixelWorld2D	access:protected
PixelWorld2D::_temp	pixelworld2d.h	/^        IplImage* _temp;$/;"	m	class:PixelWorld2D	access:protected
PixelWorld2D::_width	pixelworld2d.h	/^        int             _width;$/;"	m	class:PixelWorld2D	access:protected
PixelWorld2D::operator []	pixelworld2d.h	/^        T* operator[](int rowIndx) { return _pixels[rowIndx]; }$/;"	f	class:PixelWorld2D	access:public	signature:(int rowIndx)
PixelWorld2D::operator []	pixelworld2d.h	/^        const T* operator[](int rowIndx)const { return _pixels[rowIndx]; }$/;"	f	class:PixelWorld2D	access:public	signature:(int rowIndx) const
PixelWorld2D::show	pixelworld2d.h	/^        void show();$/;"	p	class:PixelWorld2D	access:public	signature:()
PixelWorld2D::show	pixelworld2d.h	/^void PixelWorld2D<T>::show(){$/;"	f	class:PixelWorld2D	signature:()
PixelWorld2D::~PixelWorld2D	pixelworld2d.h	/^        virtual ~PixelWorld2D ();$/;"	p	class:PixelWorld2D	access:public	signature:()
PixelWorld2D::~PixelWorld2D	pixelworld2d.h	/^PixelWorld2D<T>::~PixelWorld2D()$/;"	f	class:PixelWorld2D	signature:()
PixelWorld3D	pixelworld3d.h	/^        explicit PixelWorld3D(bool isGrid = true):_isGrid(isGrid){ };$/;"	f	class:PixelWorld3D	access:public	signature:(bool isGrid = true)
PixelWorld3D	pixelworld3d.h	/^class PixelWorld3D {$/;"	c
PixelWorld3D::PixelSet	pixelworld3d.h	/^        typedef std::set<T> PixelSet;$/;"	t	class:PixelWorld3D	access:public
PixelWorld3D::PixelWorld3D	pixelworld3d.h	/^        explicit PixelWorld3D(bool isGrid = true):_isGrid(isGrid){ };$/;"	f	class:PixelWorld3D	access:public	signature:(bool isGrid = true)
PixelWorld3D::_feature_neighbors	pixelworld3d.h	/^        std::vector<T*> _feature_neighbors(const T &t) const{ };$/;"	f	class:PixelWorld3D	access:protected	signature:(const T &t) const
PixelWorld3D::_grid_neighbors	pixelworld3d.h	/^        std::vector<T*> _grid_neighbors(const T &t) const;$/;"	p	class:PixelWorld3D	access:protected	signature:(const T &t) const
PixelWorld3D::_grid_neighbors	pixelworld3d.h	/^inline std::vector<T*> PixelWorld3D<T>::_grid_neighbors(const T &t) const{$/;"	f	class:PixelWorld3D	signature:(const T &t) const
PixelWorld3D::_isGrid	pixelworld3d.h	/^        bool            _isGrid;$/;"	m	class:PixelWorld3D	access:protected
PixelWorld3D::_pixels	pixelworld3d.h	/^        PixelSet     _pixels;    $/;"	m	class:PixelWorld3D	access:protected
PixelWorld3D::get_neighbors	pixelworld3d.h	/^        std::vector<T*> get_neighbors(const T &t) const;$/;"	p	class:PixelWorld3D	access:protected	signature:(const T &t) const
PixelWorld3D::get_neighbors	pixelworld3d.h	/^inline std::vector<T*> PixelWorld3D<T>::get_neighbors(const T &t) const{$/;"	f	class:PixelWorld3D	signature:(const T &t) const
PixelWorld3D::operator []	pixelworld3d.h	/^        T* operator[](int rowIndx) { return _pixels[rowIndx]; }$/;"	f	class:PixelWorld3D	access:public	signature:(int rowIndx)
PixelWorld3D::operator []	pixelworld3d.h	/^        const T* operator[](int rowIndx)const { return _pixels[rowIndx]; }$/;"	f	class:PixelWorld3D	access:public	signature:(int rowIndx) const
PixelWorld3D::~PixelWorld3D	pixelworld3d.h	/^        virtual ~PixelWorld3D(){ };$/;"	f	class:PixelWorld3D	access:public	signature:()
PointCloudPtr	triangulate.h	/^typedef pcl::PointCloud<PointT>::Ptr PointCloudPtr;$/;"	t
PointCloudPtr	vizblockworld.h	/^typedef pcl::PointCloud<PointT>::Ptr PointCloudPtr;$/;"	t
PointCloudSource	icp.h	/^    typedef typename Registration<PointSource, PointTarget>::PointCloudSource PointCloudSource;$/;"	t	class:IterativeClosestPoint	access:private
PointCloudSourceConstPtr	icp.h	/^    typedef typename PointCloudSource::ConstPtr PointCloudSourceConstPtr;$/;"	t	class:IterativeClosestPoint	access:private
PointCloudSourcePtr	icp.h	/^    typedef typename PointCloudSource::Ptr PointCloudSourcePtr;$/;"	t	class:IterativeClosestPoint	access:private
PointCloudTarget	icp.h	/^    typedef typename Registration<PointSource, PointTarget>::PointCloudTarget PointCloudTarget;$/;"	t	class:IterativeClosestPoint	access:private
PointF	segment2d.h	26;"	d
PointIndicesConstPtr	icp.h	/^    typedef PointIndices::ConstPtr PointIndicesConstPtr;$/;"	t	class:IterativeClosestPoint	access:private
PointIndicesPtr	icp.h	/^    typedef PointIndices::Ptr PointIndicesPtr;$/;"	t	class:IterativeClosestPoint	access:private
PointT	cluster_node.h	/^typedef pcl::PointXYZRGB PointT;$/;"	t
PointT	triangulate.cpp	/^typedef pcl::PointXYZRGB PointT;$/;"	t	file:
PointT	triangulate.h	/^typedef pcl::PointXYZRGB PointT;$/;"	t
PointT	vizblockworld.cpp	/^typedef pcl::PointXYZRGB PointT;$/;"	t	file:
PointT	vizblockworld.h	/^typedef pcl::PointXYZRGB PointT;$/;"	t
Region2D	segment2d.h	/^        struct Region2D{$/;"	s	class:Segment2D	access:public
Region3D	segment3d.h	/^        typedef Region3D_<T> Region3D;$/;"	t	class:Segment3D	access:public
Region3D_	segment3d.h	/^struct Region3D_{$/;"	s
Region3D_::_averageColor	segment3d.h	/^    typename T::MeasureColorType _averageColor;$/;"	m	struct:Region3D_	access:public
Region3D_::_boundary	segment3d.h	/^    std::vector<T*> _boundary;$/;"	m	struct:Region3D_	access:public
Region3D_::_centroid	segment3d.h	/^    PointF3D  _centroid;$/;"	m	struct:Region3D_	access:public
Region3D_::_comp	segment3d.h	/^    Component<T*> *_comp;$/;"	m	struct:Region3D_	access:public
Region3D_::_regionColor	segment3d.h	/^    m_opencv::RgbColor  _regionColor;$/;"	m	struct:Region3D_	access:public
RgbPixel2D	pixel.h	/^        RgbPixel2D(int x = 0 , int y = 0, Component<RgbPixel2D*> *parent = NULL)$/;"	f	class:RgbPixel2D	access:public	signature:(int x = 0 , int y = 0, Component<RgbPixel2D*> *parent = NULL)
RgbPixel2D	pixel.h	/^class RgbPixel2D {$/;"	c
RgbPixel2D::CHANELS	pixel.h	/^        static const int CHANELS = 3;$/;"	m	class:RgbPixel2D	access:public
RgbPixel2D::ColorType	pixel.h	/^        typedef RgbColor ColorType;$/;"	t	class:RgbPixel2D	access:public
RgbPixel2D::ISRGB	pixel.h	/^        static const bool ISRGB = true;$/;"	m	class:RgbPixel2D	access:public
RgbPixel2D::ImageType	pixel.h	/^        typedef RgbImage ImageType;$/;"	t	class:RgbPixel2D	access:public
RgbPixel2D::MeasureColorType	pixel.h	/^        typedef LuvColor MeasureColorType;$/;"	t	class:RgbPixel2D	access:public
RgbPixel2D::RgbPixel2D	pixel.h	/^        RgbPixel2D(int x = 0 , int y = 0, Component<RgbPixel2D*> *parent = NULL)$/;"	f	class:RgbPixel2D	access:public	signature:(int x = 0 , int y = 0, Component<RgbPixel2D*> *parent = NULL)
RgbPixel2D::_color	pixel.h	/^        RgbColor _color;$/;"	m	class:RgbPixel2D	access:public
RgbPixel2D::_luvColor	pixel.h	/^        LuvColor _luvColor;$/;"	m	class:RgbPixel2D	access:public
RgbPixel2D::_parent	pixel.h	/^        Component<RgbPixel2D*> *_parent;$/;"	m	class:RgbPixel2D	access:public
RgbPixel2D::_x	pixel.h	/^        int _x;$/;"	m	class:RgbPixel2D	access:public
RgbPixel2D::_y	pixel.h	/^        int _y;$/;"	m	class:RgbPixel2D	access:public
RgbPixel2D::density_distance	pixel.h	/^        static double density_distance(const RgbPixel2D &a, const RgbPixel2D &b){$/;"	f	class:RgbPixel2D	access:public	signature:(const RgbPixel2D &a, const RgbPixel2D &b)
RgbPixel2D::get_color	pixel.h	/^        const RgbColor&  get_color() const{$/;"	f	class:RgbPixel2D	access:public	signature:() const
RgbPixel2D::get_density	pixel.h	/^        double get_density( ) const{$/;"	f	class:RgbPixel2D	access:public	signature:( ) const
RgbPixel2D::get_measure_color	pixel.h	/^        const LuvColor& get_measure_color()const {$/;"	f	class:RgbPixel2D	access:public	signature:() const
RgbPixel2D::operator <	pixel.h	/^        bool operator < (const RgbPixel2D &other) const{$/;"	f	class:RgbPixel2D	access:public	signature:(const RgbPixel2D &other) const
RgbPixel2D::set_color	pixel.h	/^        void set_color(const RgbColor &rgb){$/;"	f	class:RgbPixel2D	access:public	signature:(const RgbColor &rgb)
RgbPixel2D::set_location	pixel.h	/^        void set_location(int x, int y){$/;"	f	class:RgbPixel2D	access:public	signature:(int x, int y)
RgbPixel2D::spatial_distance	pixel.h	/^        static double spatial_distance(const RgbPixel2D &a, const RgbPixel2D &b){$/;"	f	class:RgbPixel2D	access:public	signature:(const RgbPixel2D &a, const RgbPixel2D &b)
RgbPixel3D	pixel.h	/^        RgbPixel3D(const RgbColor &color, float x = 0 , float y = 0, float z = 0, int size = 0):_x(x), _y(y), _z(z),$/;"	f	class:RgbPixel3D	access:public	signature:(const RgbColor &color, float x = 0 , float y = 0, float z = 0, int size = 0)
RgbPixel3D	pixel.h	/^        RgbPixel3D(float x = 0, float y = 0, float z = 0, Component<RgbPixel3D*> *parent = NULL)$/;"	f	class:RgbPixel3D	access:public	signature:(float x = 0, float y = 0, float z = 0, Component<RgbPixel3D*> *parent = NULL)
RgbPixel3D	pixel.h	/^class RgbPixel3D {$/;"	c
RgbPixel3D::ColorType	pixel.h	/^        typedef RgbColor ColorType;$/;"	t	class:RgbPixel3D	access:public
RgbPixel3D::MeasureColorType	pixel.h	/^        typedef LuvColor MeasureColorType;$/;"	t	class:RgbPixel3D	access:public
RgbPixel3D::RgbPixel3D	pixel.h	/^        RgbPixel3D(const RgbColor &color, float x = 0 , float y = 0, float z = 0, int size = 0):_x(x), _y(y), _z(z),$/;"	f	class:RgbPixel3D	access:public	signature:(const RgbColor &color, float x = 0 , float y = 0, float z = 0, int size = 0)
RgbPixel3D::RgbPixel3D	pixel.h	/^        RgbPixel3D(float x = 0, float y = 0, float z = 0, Component<RgbPixel3D*> *parent = NULL)$/;"	f	class:RgbPixel3D	access:public	signature:(float x = 0, float y = 0, float z = 0, Component<RgbPixel3D*> *parent = NULL)
RgbPixel3D::_color	pixel.h	/^        RgbColor _color;$/;"	m	class:RgbPixel3D	access:public
RgbPixel3D::_luvColor	pixel.h	/^        LuvColor _luvColor;$/;"	m	class:RgbPixel3D	access:public
RgbPixel3D::_parent	pixel.h	/^        Component<RgbPixel3D*> *_parent;$/;"	m	class:RgbPixel3D	access:public
RgbPixel3D::_size	pixel.h	/^        int _size;$/;"	m	class:RgbPixel3D	access:public
RgbPixel3D::_x	pixel.h	/^        float _x;$/;"	m	class:RgbPixel3D	access:public
RgbPixel3D::_y	pixel.h	/^        float _y;$/;"	m	class:RgbPixel3D	access:public
RgbPixel3D::_z	pixel.h	/^        float _z;$/;"	m	class:RgbPixel3D	access:public
RgbPixel3D::density_distance	pixel.h	/^        static double density_distance(const RgbPixel3D &a, const RgbPixel3D &b){$/;"	f	class:RgbPixel3D	access:public	signature:(const RgbPixel3D &a, const RgbPixel3D &b)
RgbPixel3D::get_color	pixel.h	/^        RgbColor  get_color() const{$/;"	f	class:RgbPixel3D	access:public	signature:() const
RgbPixel3D::get_density	pixel.h	/^        double get_density( ) const{$/;"	f	class:RgbPixel3D	access:public	signature:( ) const
RgbPixel3D::get_measure_color	pixel.h	/^        const LuvColor& get_measure_color()const {$/;"	f	class:RgbPixel3D	access:public	signature:() const
RgbPixel3D::operator <	pixel.h	/^        bool operator < (const RgbPixel3D &other) const{$/;"	f	class:RgbPixel3D	access:public	signature:(const RgbPixel3D &other) const
RgbPixel3D::set_color	pixel.h	/^        void set_color(const RgbColor &rgb){$/;"	f	class:RgbPixel3D	access:public	signature:(const RgbColor &rgb)
RgbPixel3D::set_location	pixel.h	/^        void set_location(float x, float y, float z){$/;"	f	class:RgbPixel3D	access:public	signature:(float x, float y, float z)
RgbPixel3D::spatial_distance	pixel.h	/^        static double spatial_distance(const RgbPixel3D &a, const RgbPixel3D &b){$/;"	f	class:RgbPixel3D	access:public	signature:(const RgbPixel3D &a, const RgbPixel3D &b)
SCALE	component.h	/^static const double SCALE = 0;$/;"	v
SEGMENT2D_H	segment2d.h	11;"	d
SEGMENT3D_H	segment3d.h	10;"	d
SegMethod	segment3d.h	/^        SegMethod(ImageModel &imgModel):_imgModel(imgModel){ $/;"	f	class:SegMethod	access:public	signature:(ImageModel &imgModel)
SegMethod	segment3d.h	/^class SegMethod: public xmlrpc_c::method {$/;"	c	inherits:xmlrpc_c::method
SegMethod::ImageModel	segment3d.h	/^        typedef m_graph::VizGraph<Region3D_<T>, int> ImageModel;$/;"	t	class:SegMethod	access:public
SegMethod::SegMethod	segment3d.h	/^        SegMethod(ImageModel &imgModel):_imgModel(imgModel){ $/;"	f	class:SegMethod	access:public	signature:(ImageModel &imgModel)
SegMethod::_imgModel	segment3d.h	/^        ImageModel &_imgModel;$/;"	m	class:SegMethod	access:private
SegMethod::_rst	segment3d.h	/^        xmlrpc_c::value _rst;$/;"	m	class:SegMethod	access:private
SegMethod::execute	segment3d.h	/^        void execute(xmlrpc_c::paramList const& paramList,$/;"	f	class:SegMethod	access:public	signature:(xmlrpc_c::paramList const& paramList, xmlrpc_c::value * const retvalP)
Segment2D	segment2d.h	/^        explicit Segment2D(std::string filename, bool isGrid = true);$/;"	p	class:Segment2D	access:public	signature:(std::string filename, bool isGrid = true)
Segment2D	segment2d.h	/^Segment2D<T>::Segment2D(std::string filename, bool isGrid):PixelWorld2D<T>(filename),$/;"	f	class:Segment2D	signature:(std::string filename, bool isGrid)
Segment2D	segment2d.h	/^class Segment2D: public PixelWorld2D<T> {$/;"	c	inherits:PixelWorld2D
Segment2D::Component2D	segment2d.h	/^        typedef Component<T*> Component2D;$/;"	t	class:Segment2D	access:public
Segment2D::Filter	segment2d.h	/^        struct Filter : public unary_function<Component2D, bool> {$/;"	s	class:Segment2D	inherits:unary_function	access:public
Segment2D::Filter::Filter	segment2d.h	/^            Filter(int n = 1):_scale(n){ }$/;"	f	struct:Segment2D::Filter	access:public	signature:(int n = 1)
Segment2D::Filter::_scale	segment2d.h	/^            int _scale;$/;"	m	struct:Segment2D::Filter	access:public
Segment2D::Filter::operator ()	segment2d.h	/^            bool  operator()(const Component2D& arg1) const{$/;"	f	struct:Segment2D::Filter	access:public	signature:(const Component2D& arg1) const
Segment2D::ImageModel	segment2d.h	/^        typedef m_graph::VizGraph<Region2D, int> ImageModel;$/;"	t	class:Segment2D	access:public
Segment2D::Region2D	segment2d.h	/^        struct Region2D{$/;"	s	class:Segment2D	access:public
Segment2D::Region2D::_averageColor	segment2d.h	/^            typename T::MeasureColorType _averageColor;$/;"	m	struct:Segment2D::Region2D	access:public
Segment2D::Region2D::_boundary	segment2d.h	/^            std::vector<T*> _boundary;$/;"	m	struct:Segment2D::Region2D	access:public
Segment2D::Region2D::_centroid	segment2d.h	/^            PointF  _centroid;$/;"	m	struct:Segment2D::Region2D	access:public
Segment2D::Region2D::_comp	segment2d.h	/^            Component2D *_comp;$/;"	m	struct:Segment2D::Region2D	access:public
Segment2D::Region2D::_regionColor	segment2d.h	/^            m_opencv::RgbColor  _regionColor;$/;"	m	struct:Segment2D::Region2D	access:public
Segment2D::Segment2D	segment2d.h	/^        explicit Segment2D(std::string filename, bool isGrid = true);$/;"	p	class:Segment2D	access:public	signature:(std::string filename, bool isGrid = true)
Segment2D::Segment2D	segment2d.h	/^Segment2D<T>::Segment2D(std::string filename, bool isGrid):PixelWorld2D<T>(filename),$/;"	f	class:Segment2D	signature:(std::string filename, bool isGrid)
Segment2D::WeightEdge2D	segment2d.h	/^        typedef WeightEdge<T*> WeightEdge2D;$/;"	t	class:Segment2D	access:public
Segment2D::_components	segment2d.h	/^        std::vector<Component2D> _components;$/;"	m	class:Segment2D	access:private
Segment2D::_edge_weight	segment2d.h	/^        double _edge_weight(const T &a, const T &b){ return T::density_distance(a,b) ;}$/;"	f	class:Segment2D	access:protected	signature:(const T &a, const T &b)
Segment2D::_extract_model	segment2d.h	/^        void _extract_model(int noise = 1);$/;"	p	class:Segment2D	access:protected	signature:(int noise = 1)
Segment2D::_extract_model	segment2d.h	/^void Segment2D<T>::_extract_model(int noise){$/;"	f	class:Segment2D	signature:(int noise)
Segment2D::_feature_neighbors	segment2d.h	/^        std::vector<T*> _feature_neighbors(const T &t) const;$/;"	p	class:Segment2D	access:protected	signature:(const T &t) const
Segment2D::_feature_neighbors	segment2d.h	/^std::vector<T*> Segment2D<T>::_feature_neighbors(const T &t) const{$/;"	f	class:Segment2D	signature:(const T &t) const
Segment2D::_gaussian	segment2d.h	/^        void _gaussian(){ }$/;"	f	class:Segment2D	access:protected	signature:()
Segment2D::_grid_neighbors	segment2d.h	/^        std::vector<T*> _grid_neighbors(const T &t) const;$/;"	p	class:Segment2D	access:protected	signature:(const T &t) const
Segment2D::_grid_neighbors	segment2d.h	/^inline std::vector<T*> Segment2D<T>::_grid_neighbors(const T &t) const{$/;"	f	class:Segment2D	signature:(const T &t) const
Segment2D::_imgModel	segment2d.h	/^        ImageModel _imgModel;$/;"	m	class:Segment2D	access:private
Segment2D::_isGrid	segment2d.h	/^        bool            _isGrid;$/;"	m	class:Segment2D	access:private
Segment2D::_is_inside	segment2d.h	/^        bool _is_inside(int x, int y) const;$/;"	p	class:Segment2D	access:protected	signature:(int x, int y) const
Segment2D::_is_inside	segment2d.h	/^inline bool Segment2D<T>::_is_inside(int x, int y) const{$/;"	f	class:Segment2D	signature:(int x, int y) const
Segment2D::_noises	segment2d.h	/^        std::set<Component2D> _noises;$/;"	m	class:Segment2D	access:private
Segment2D::_optimze_model	segment2d.h	/^        void _optimze_model(int scale );$/;"	p	class:Segment2D	access:protected	signature:(int scale )
Segment2D::_optimze_model	segment2d.h	/^void Segment2D<T>::_optimze_model(int scale){$/;"	f	class:Segment2D	signature:(int scale)
Segment2D::filter	segment2d.h	/^        void filter(int noise = 1);$/;"	p	class:Segment2D	access:public	signature:(int noise = 1)
Segment2D::filter	segment2d.h	/^void Segment2D<T>::filter(int noise){$/;"	f	class:Segment2D	signature:(int noise)
Segment2D::get_neighbors	segment2d.h	/^        std::vector<T*> get_neighbors(const T &t) const;$/;"	p	class:Segment2D	access:public	signature:(const T &t) const
Segment2D::get_neighbors	segment2d.h	/^inline std::vector<T*> Segment2D<T>::get_neighbors(const T &t) const{$/;"	f	class:Segment2D	signature:(const T &t) const
Segment2D::model_info	segment2d.h	/^        void model_info( );$/;"	p	class:Segment2D	access:public	signature:( )
Segment2D::model_info	segment2d.h	/^void Segment2D<T>::model_info(){$/;"	f	class:Segment2D	signature:()
Segment2D::save	segment2d.h	/^        void save(std::string filename, int optScale = 0, int filterSize = 0);$/;"	p	class:Segment2D	access:public	signature:(std::string filename, int optScale = 0, int filterSize = 0)
Segment2D::save	segment2d.h	/^void Segment2D<T>::save(std::string filename, int optScale, int filterSize){$/;"	f	class:Segment2D	signature:(std::string filename, int optScale, int filterSize)
Segment2D::segment	segment2d.h	/^        void segment(int arg = 70);$/;"	p	class:Segment2D	access:public	signature:(int arg = 70)
Segment2D::segment	segment2d.h	/^void Segment2D<T>::segment(int arg){$/;"	f	class:Segment2D	signature:(int arg)
Segment2D::~Segment2D	segment2d.h	/^        virtual ~Segment2D(){ };$/;"	f	class:Segment2D	access:public	signature:()
Segment3D	segment3d.h	/^        Segment3D(bool isGrid = true);$/;"	p	class:Segment3D	access:public	signature:(bool isGrid = true)
Segment3D	segment3d.h	/^        Segment3D(const pcl::PointCloud<pcl::PointXYZRGBA>::ConstPtr& cloud, bool isGrid = false);$/;"	p	class:Segment3D	access:public	signature:(const pcl::PointCloud<pcl::PointXYZRGBA>::ConstPtr& cloud, bool isGrid = false)
Segment3D	segment3d.h	/^Segment3D<T>::Segment3D(bool isGrid):PixelWorld3D<T>(isGrid)$/;"	f	class:Segment3D	signature:(bool isGrid)
Segment3D	segment3d.h	/^Segment3D<T>::Segment3D(const pcl::PointCloud<pcl::PointXYZRGBA>::ConstPtr& cloud, $/;"	f	class:Segment3D	signature:(const pcl::PointCloud<pcl::PointXYZRGBA>::ConstPtr& cloud, bool isGrid)
Segment3D	segment3d.h	/^class Segment3D:public PixelWorld3D<T> {$/;"	c	inherits:PixelWorld3D
Segment3D::Component3D	segment3d.h	/^        typedef Component<T*> Component3D;$/;"	t	class:Segment3D	access:public
Segment3D::ImageModel	segment3d.h	/^        typedef m_graph::VizGraph<Region3D, int> ImageModel;$/;"	t	class:Segment3D	access:public
Segment3D::PixelSet	segment3d.h	/^        typedef typename PixelWorld3D<T>::PixelSet PixelSet;$/;"	t	class:Segment3D	access:public
Segment3D::Region3D	segment3d.h	/^        typedef Region3D_<T> Region3D;$/;"	t	class:Segment3D	access:public
Segment3D::Segment3D	segment3d.h	/^        Segment3D(bool isGrid = true);$/;"	p	class:Segment3D	access:public	signature:(bool isGrid = true)
Segment3D::Segment3D	segment3d.h	/^        Segment3D(const pcl::PointCloud<pcl::PointXYZRGBA>::ConstPtr& cloud, bool isGrid = false);$/;"	p	class:Segment3D	access:public	signature:(const pcl::PointCloud<pcl::PointXYZRGBA>::ConstPtr& cloud, bool isGrid = false)
Segment3D::Segment3D	segment3d.h	/^Segment3D<T>::Segment3D(bool isGrid):PixelWorld3D<T>(isGrid)$/;"	f	class:Segment3D	signature:(bool isGrid)
Segment3D::Segment3D	segment3d.h	/^Segment3D<T>::Segment3D(const pcl::PointCloud<pcl::PointXYZRGBA>::ConstPtr& cloud, $/;"	f	class:Segment3D	signature:(const pcl::PointCloud<pcl::PointXYZRGBA>::ConstPtr& cloud, bool isGrid)
Segment3D::WeightEdge3D	segment3d.h	/^        typedef WeightEdge<T*> WeightEdge3D;$/;"	t	class:Segment3D	access:public
Segment3D::_components	segment3d.h	/^        std::list<Component3D> _components;$/;"	m	class:Segment3D	access:private
Segment3D::_edge_weight	segment3d.h	/^        double _edge_weight(const T &a, const T &b){ return T::density_distance(a,b) ;}$/;"	f	class:Segment3D	access:protected	signature:(const T &a, const T &b)
Segment3D::_extract_model	segment3d.h	/^        void _extract_model(int noise);$/;"	p	class:Segment3D	access:public	signature:(int noise)
Segment3D::_extract_model	segment3d.h	/^void Segment3D<T>::_extract_model(int noise){$/;"	f	class:Segment3D	signature:(int noise)
Segment3D::_gaussian	segment3d.h	/^        void _gaussian(){ }$/;"	f	class:Segment3D	access:protected	signature:()
Segment3D::_imgModel	segment3d.h	/^        ImageModel _imgModel;$/;"	m	class:Segment3D	access:private
Segment3D::_noises	segment3d.h	/^        std::set<Component3D> _noises;$/;"	m	class:Segment3D	access:private
Segment3D::save	segment3d.h	/^        void save(std::string filename, int optScale = 0, int filterSize = 0);$/;"	p	class:Segment3D	access:public	signature:(std::string filename, int optScale = 0, int filterSize = 0)
Segment3D::save	segment3d.h	/^void Segment3D<T>::save(std::string filename, int optScale, int filterSize){$/;"	f	class:Segment3D	signature:(std::string filename, int optScale, int filterSize)
Segment3D::segment	segment3d.h	/^        void segment(int arg = 0);$/;"	p	class:Segment3D	access:public	signature:(int arg = 0)
Segment3D::segment	segment3d.h	/^void Segment3D<T>::segment(int arg ){$/;"	f	class:Segment3D	signature:(int arg )
Segment3D::~Segment3D	segment3d.h	/^        ~Segment3D(){ };$/;"	f	class:Segment3D	access:public	signature:()
SizeType	graph.h	/^        typedef typename BaseGraph<GraphContainer>::SizeType SizeType;$/;"	t	class:m_graph::AutoUniGraph	access:public
SizeType	graph.h	/^        typedef typename BaseGraph<GraphContainer>::SizeType SizeType;$/;"	t	class:m_graph::ManualUniGraph	access:public
SizeType	graph.h	/^        typedef typename graph_traits<GraphContainer>::vertices_size_type SizeType;$/;"	t	class:m_graph::BaseGraph	access:public
TRIANGULATE_H	triangulate.h	29;"	d
TopoGraph	triangulate.h	/^        typedef m_graph::AutoUniGraph<boostGraph2, TrNode> TopoGraph;$/;"	t	class:MyTriangulation	access:protected
TrNode	cluster_node.h	/^    TrNode(){ size = 0; triangles = NULL; parentId = -1;}$/;"	f	struct:TrNode	access:public	signature:()
TrNode	cluster_node.h	/^    TrNode(int id1_, int id2_):id1(id1_), id2(id2_),$/;"	f	struct:TrNode	access:public	signature:(int id1_, int id2_)
TrNode	cluster_node.h	/^struct TrNode{$/;"	s
TrNode::TrNode	cluster_node.h	/^    TrNode(){ size = 0; triangles = NULL; parentId = -1;}$/;"	f	struct:TrNode	access:public	signature:()
TrNode::TrNode	cluster_node.h	/^    TrNode(int id1_, int id2_):id1(id1_), id2(id2_),$/;"	f	struct:TrNode	access:public	signature:(int id1_, int id2_)
TrNode::coefficient	cluster_node.h	/^    Coefficient coefficient;$/;"	m	struct:TrNode	access:public
TrNode::cost	cluster_node.h	/^    double cost;$/;"	m	struct:TrNode	access:public
TrNode::cost0	cluster_node.h	/^    double cost0;$/;"	m	struct:TrNode	access:public
TrNode::cost1	cluster_node.h	/^    double cost1;$/;"	m	struct:TrNode	access:public
TrNode::cost2	cluster_node.h	/^    double cost2;$/;"	m	struct:TrNode	access:public
TrNode::defaultCoef	cluster_node.h	/^    static Coefficient defaultCoef;$/;"	m	struct:TrNode	access:public
TrNode::friendId	cluster_node.h	/^    int friendId;$/;"	m	struct:TrNode	access:public
TrNode::geometry_weight	cluster_node.h	/^    static double geometry_weight(const TrNode &node){$/;"	f	struct:TrNode	access:public	signature:(const TrNode &node)
TrNode::id1	cluster_node.h	/^    int id1;$/;"	m	struct:TrNode	access:public
TrNode::id2	cluster_node.h	/^    int id2;$/;"	m	struct:TrNode	access:public
TrNode::numLeafs	cluster_node.cpp	/^int TrNode::numLeafs = 0;$/;"	m	class:TrNode	file:
TrNode::numLeafs	cluster_node.h	/^    static int numLeafs;$/;"	m	struct:TrNode	access:public
TrNode::operator <	cluster_node.h	/^    bool operator<(const TrNode& r) const{$/;"	f	struct:TrNode	access:public	signature:(const TrNode& r) const
TrNode::parentId	cluster_node.h	/^    int parentId;$/;"	m	struct:TrNode	access:public
TrNode::percent	cluster_node.h	/^    double percent;$/;"	m	struct:TrNode	access:public
TrNode::size	cluster_node.h	/^    int size;$/;"	m	struct:TrNode	access:public
TrNode::triangles	cluster_node.h	/^    void **triangles;$/;"	m	struct:TrNode	access:public
TrNode::type	cluster_node.h	/^    unsigned char type;$/;"	m	struct:TrNode	access:public
TrNode::weight	cluster_node.h	/^    double weight;$/;"	m	struct:TrNode	access:public
TrNode::~TrNode	cluster_node.h	/^    ~TrNode(){$/;"	f	struct:TrNode	access:public	signature:()
TrianglePtrs	triangulate.cpp	/^typedef std::vector<Triangle*> TrianglePtrs;$/;"	t	file:
TrianglesOfComponent	triangulate.h	/^        TrianglesOfComponent(std::vector<Triangle*> *t):_triangles(t){ }$/;"	f	class:TrianglesOfComponent	access:public	signature:(std::vector<Triangle*> *t)
TrianglesOfComponent	triangulate.h	/^class TrianglesOfComponent : public boost::default_bfs_visitor$/;"	c	inherits:boost::default_bfs_visitor
TrianglesOfComponent::TrianglesOfComponent	triangulate.h	/^        TrianglesOfComponent(std::vector<Triangle*> *t):_triangles(t){ }$/;"	f	class:TrianglesOfComponent	access:public	signature:(std::vector<Triangle*> *t)
TrianglesOfComponent::_triangles	triangulate.h	/^        std::vector<Triangle*> *_triangles;$/;"	m	class:TrianglesOfComponent	access:public
TrianglesOfComponent::discover_vertex	triangulate.h	/^            void discover_vertex(Vertex u, const Graph & g) const$/;"	f	class:TrianglesOfComponent	access:public	signature:(Vertex u, const Graph & g) const
UTIL_H	util.h	2;"	d
VIZBLOCKWORLD_H	vizblockworld.h	3;"	d
VizBlockWorld	vizblockworld.h	/^        VizBlockWorld (){$/;"	f	class:VizBlockWorld	access:public	signature:()
VizBlockWorld	vizblockworld.h	/^class VizBlockWorld {$/;"	c
VizBlockWorld::VizBlockWorld	vizblockworld.h	/^        VizBlockWorld (){$/;"	f	class:VizBlockWorld	access:public	signature:()
VizBlockWorld::_cloud	vizblockworld.h	/^        pcl::PointCloud<PointT>::Ptr _cloud;$/;"	m	class:VizBlockWorld	access:private
VizBlockWorld::_objId	vizblockworld.h	/^        int _objId;$/;"	m	class:VizBlockWorld	access:private
VizBlockWorld::_viewer	vizblockworld.h	/^        pcl::visualization::PCLVisualizer *_viewer;$/;"	m	class:VizBlockWorld	access:private
VizBlockWorld::_x_offset	vizblockworld.h	/^        float _x_offset;$/;"	m	class:VizBlockWorld	access:private
VizBlockWorld::_y_offset	vizblockworld.h	/^        float _y_offset;$/;"	m	class:VizBlockWorld	access:private
VizBlockWorld::_z_offset	vizblockworld.h	/^        float _z_offset;$/;"	m	class:VizBlockWorld	access:private
VizBlockWorld::add_cloud	vizblockworld.h	/^        std::string add_cloud(const pcl::PointCloud<PointT>::Ptr cloud, int viewport = 0, int pointSize = 1){$/;"	f	class:VizBlockWorld	access:public	signature:(const pcl::PointCloud<PointT>::Ptr cloud, int viewport = 0, int pointSize = 1)
VizBlockWorld::add_cube	vizblockworld.h	/^        std::string add_cube(float x, float y, float z, int r, int g, int b, int viewport = 0, float cubeSize = 1, int STYLE = 1){$/;"	f	class:VizBlockWorld	access:public	signature:(float x, float y, float z, int r, int g, int b, int viewport = 0, float cubeSize = 1, int STYLE = 1)
VizBlockWorld::add_cylinder	vizblockworld.h	/^        std::string add_cylinder(double centerX, double centerY, double centerZ, double normalX,$/;"	f	class:VizBlockWorld	access:public	signature:(double centerX, double centerY, double centerZ, double normalX, double normalY, double normalZ, double radius, int viewport = 0)
VizBlockWorld::add_line	vizblockworld.h	/^        std::string add_line(double aX, double aY, double aZ, $/;"	f	class:VizBlockWorld	access:public	signature:(double aX, double aY, double aZ, double bX, double bY, double bZ, int r, int g, int b, int viewport = 0)
VizBlockWorld::add_line	vizblockworld.h	/^        std::string add_line(double aX, double aY, double aZ, $/;"	f	class:VizBlockWorld	access:public	signature:(double aX, double aY, double aZ, double bX, double bY, double bZ, int viewport = 0)
VizBlockWorld::add_mesh	vizblockworld.h	/^        std::string  add_mesh(const pcl::PolygonMesh *mesh, int viewport = 0){$/;"	f	class:VizBlockWorld	access:public	signature:(const pcl::PolygonMesh *mesh, int viewport = 0)
VizBlockWorld::add_plane	vizblockworld.h	/^        std::string add_plane(double a, double b, double c, double d, int viewport = 0){$/;"	f	class:VizBlockWorld	access:public	signature:(double a, double b, double c, double d, int viewport = 0)
VizBlockWorld::add_plane	vizblockworld.h	/^        std::string add_plane(double px, double py, double pz, double normalX, double normalY, double normalZ, int viewport = 0){$/;"	f	class:VizBlockWorld	access:public	signature:(double px, double py, double pz, double normalX, double normalY, double normalZ, int viewport = 0)
VizBlockWorld::add_point	vizblockworld.h	/^        inline void  add_point(float x, float y, float z, int r, int g, int b, float unit = 1){ $/;"	f	class:VizBlockWorld	access:public	signature:(float x, float y, float z, int r, int g, int b, float unit = 1)
VizBlockWorld::add_point	vizblockworld.h	/^        inline void add_point(const PointT &p, int r, int g, int b, float unit = 1){$/;"	f	class:VizBlockWorld	access:public	signature:(const PointT &p, int r, int g, int b, float unit = 1)
VizBlockWorld::add_sphere	vizblockworld.h	/^        std::string add_sphere(double centerX, double centerY, double centerZ, double radius, $/;"	f	class:VizBlockWorld	access:public	signature:(double centerX, double centerY, double centerZ, double radius, int r, int g, int b, int viewport = 0)
VizBlockWorld::add_sphere	vizblockworld.h	/^        std::string add_sphere(double centerX, double centerY, double centerZ, double radius, int viewport = 0){$/;"	f	class:VizBlockWorld	access:public	signature:(double centerX, double centerY, double centerZ, double radius, int viewport = 0)
VizBlockWorld::add_text	vizblockworld.h	/^        std::string add_text(const std::string &text, int x, int y, int viewport = 0){$/;"	f	class:VizBlockWorld	access:public	signature:(const std::string &text, int x, int y, int viewport = 0)
VizBlockWorld::add_text3D	vizblockworld.h	/^        std::string add_text3D(const std::string &text, float x, float y, float z, $/;"	f	class:VizBlockWorld	access:public	signature:(const std::string &text, float x, float y, float z, int r, int g, int b, double scale = 1.0, int viewport = 0)
VizBlockWorld::clear	vizblockworld.h	/^        void clear(int viewport = 0){$/;"	f	class:VizBlockWorld	access:public	signature:(int viewport = 0)
VizBlockWorld::create_h_viewport	vizblockworld.h	/^        void create_h_viewport(int &v1, int &v2){$/;"	f	class:VizBlockWorld	access:public	signature:(int &v1, int &v2)
VizBlockWorld::create_v_viewport	vizblockworld.h	/^        void create_v_viewport(int &v1, int &v2){$/;"	f	class:VizBlockWorld	access:public	signature:(int &v1, int &v2)
VizBlockWorld::create_viewport	vizblockworld.h	/^        void create_viewport(float xmin, float ymin, float xmax, float ymax, int &viewport){$/;"	f	class:VizBlockWorld	access:public	signature:(float xmin, float ymin, float xmax, float ymax, int &viewport)
VizBlockWorld::create_viewport_camera	vizblockworld.h	/^        void create_viewport_camera(int view){$/;"	f	class:VizBlockWorld	access:public	signature:(int view)
VizBlockWorld::display	vizblockworld.cpp	/^void VizBlockWorld::display(){$/;"	f	class:VizBlockWorld	signature:()
VizBlockWorld::display	vizblockworld.cpp	/^void VizBlockWorld::display(std::vector<pcl::visualization::PCLVisualizer*> viewers){$/;"	f	class:VizBlockWorld	signature:(std::vector<pcl::visualization::PCLVisualizer*> viewers)
VizBlockWorld::display	vizblockworld.h	/^        static void display(std::vector<pcl::visualization::PCLVisualizer*> viewers);$/;"	p	class:VizBlockWorld	access:public	signature:(std::vector<pcl::visualization::PCLVisualizer*> viewers)
VizBlockWorld::display	vizblockworld.h	/^        void display();$/;"	p	class:VizBlockWorld	access:public	signature:()
VizBlockWorld::draw	vizblockworld.h	/^        void draw(){ _viewer->initCameraParameters (); }$/;"	f	class:VizBlockWorld	access:public	signature:()
VizBlockWorld::generte_mesh	vizblockworld.cpp	/^void VizBlockWorld::generte_mesh(const pcl::PointCloud<pcl::PointXYZ>::Ptr cloud, pcl::PolygonMesh *triangles){$/;"	f	class:VizBlockWorld	signature:(const pcl::PointCloud<pcl::PointXYZ>::Ptr cloud, pcl::PolygonMesh *triangles)
VizBlockWorld::generte_mesh	vizblockworld.h	/^        void generte_mesh(pcl::PointCloud<pcl::PointXYZ>::Ptr cloud, pcl::PolygonMesh *triangles);$/;"	p	class:VizBlockWorld	access:public	signature:(pcl::PointCloud<pcl::PointXYZ>::Ptr cloud, pcl::PolygonMesh *triangles)
VizBlockWorld::get_viewer	vizblockworld.h	/^        pcl::visualization::PCLVisualizer *get_viewer(){$/;"	f	class:VizBlockWorld	access:public	signature:()
VizBlockWorld::move2offset	vizblockworld.h	/^            void move2offset(T cloud, float unit = 1){$/;"	f	class:VizBlockWorld	access:public	signature:(T cloud, float unit = 1)
VizBlockWorld::push_def_cloud	vizblockworld.h	/^        std::string push_def_cloud(int viewport = 0, int pointSize = 1){$/;"	f	class:VizBlockWorld	access:public	signature:(int viewport = 0, int pointSize = 1)
VizBlockWorld::register_keyboard_event	vizblockworld.h	/^        void register_keyboard_event(void (*callback) (const pcl::visualization::KeyboardEvent &event,$/;"	f	class:VizBlockWorld	access:public	signature:(void (*callback) (const pcl::visualization::KeyboardEvent &event, void *viewer_void))
VizBlockWorld::register_mouse_event	vizblockworld.h	/^        void register_mouse_event(void (*callback) (const pcl::visualization::MouseEvent &event,$/;"	f	class:VizBlockWorld	access:public	signature:(void (*callback) (const pcl::visualization::MouseEvent &event, void *viewer_void))
VizBlockWorld::remove_cloud	vizblockworld.h	/^        void remove_cloud(const std::string &id){$/;"	f	class:VizBlockWorld	access:public	signature:(const std::string &id)
VizBlockWorld::remove_shape	vizblockworld.h	/^        void remove_shape(const std::string &id){$/;"	f	class:VizBlockWorld	access:public	signature:(const std::string &id)
VizBlockWorld::reset_camera	vizblockworld.h	/^        void reset_camera(){$/;"	f	class:VizBlockWorld	access:public	signature:()
VizBlockWorld::save	vizblockworld.h	/^        void save(std::string filename){$/;"	f	class:VizBlockWorld	access:public	signature:(std::string filename)
VizBlockWorld::set_backgroundcolor	vizblockworld.h	/^        void set_backgroundcolor(int r, int g, int b, int viewport = 0){$/;"	f	class:VizBlockWorld	access:public	signature:(int r, int g, int b, int viewport = 0)
VizBlockWorld::set_def_cloud	vizblockworld.h	/^        void set_def_cloud(pcl::PointCloud<PointT>::Ptr cloud){ _cloud = cloud; }$/;"	f	class:VizBlockWorld	access:public	signature:(pcl::PointCloud<PointT>::Ptr cloud)
VizBlockWorld::set_offset	vizblockworld.h	/^        void set_offset(float x, float y, float z){ _x_offset = x; _y_offset = y; _z_offset = z; }$/;"	f	class:VizBlockWorld	access:public	signature:(float x, float y, float z)
VizBlockWorld::set_render	vizblockworld.h	/^        void set_render(){$/;"	f	class:VizBlockWorld	access:public	signature:()
VizBlockWorld::set_view	vizblockworld.h	/^        void set_view(std::string object){ _viewer->resetCameraViewpoint(object); }$/;"	f	class:VizBlockWorld	access:public	signature:(std::string object)
WeightEdge	component.h	/^        WeightEdge (double weight, T b, T e):_weight(weight), _b(b), _e(e){ };$/;"	f	class:WeightEdge	access:public	signature:(double weight, T b, T e)
WeightEdge	component.h	/^class WeightEdge {$/;"	c
WeightEdge2D	segment2d.h	/^        typedef WeightEdge<T*> WeightEdge2D;$/;"	t	class:Segment2D	access:public
WeightEdge3D	segment3d.h	/^        typedef WeightEdge<T*> WeightEdge3D;$/;"	t	class:Segment3D	access:public
WeightEdge::WeightEdge	component.h	/^        WeightEdge (double weight, T b, T e):_weight(weight), _b(b), _e(e){ };$/;"	f	class:WeightEdge	access:public	signature:(double weight, T b, T e)
WeightEdge::_b	component.h	/^        T _b;$/;"	m	class:WeightEdge	access:public
WeightEdge::_e	component.h	/^        T _e;$/;"	m	class:WeightEdge	access:public
WeightEdge::_weight	component.h	/^        double _weight;$/;"	m	class:WeightEdge	access:public
WeightEdge::m	component.h	/^        int m;$/;"	m	class:WeightEdge	access:public
WeightEdge::operator <	component.h	/^        bool operator < (const WeightEdge &r) const{$/;"	f	class:WeightEdge	access:public	signature:(const WeightEdge &r) const
Weights	emd.h	/^  float *Weights;       \/* Pointer to the weights of the features *\/$/;"	m	struct:__anon1	access:public
_C	emd.cpp	/^static float _C[MAX_SIG_SIZE1][MAX_SIG_SIZE1];\/* THE COST MATRIX *\/$/;"	v	file:
_ColsX	emd.cpp	/^static node2_t *_RowsX[MAX_SIG_SIZE1], *_ColsX[MAX_SIG_SIZE1];$/;"	v	file:
_EMD_H	emd.h	2;"	d
_EndX	emd.cpp	/^static node2_t *_EndX, *_EnterX;$/;"	v	file:
_EnterX	emd.cpp	/^static node2_t *_EndX, *_EnterX;$/;"	v	file:
_IsX	emd.cpp	/^static char _IsX[MAX_SIG_SIZE1][MAX_SIG_SIZE1];$/;"	v	file:
_RowsX	emd.cpp	/^static node2_t *_RowsX[MAX_SIG_SIZE1], *_ColsX[MAX_SIG_SIZE1];$/;"	v	file:
_X	emd.cpp	/^static node2_t _X[MAX_SIG_SIZE1*2];            \/* THE BASIC VARIABLES VECTOR *\/$/;"	v	file:
__anon1::Features	emd.h	/^  feature_t *Features;  \/* Pointer to the features vector *\/$/;"	m	struct:__anon1	access:public
__anon1::Weights	emd.h	/^  float *Weights;       \/* Pointer to the weights of the features *\/$/;"	m	struct:__anon1	access:public
__anon1::n	emd.h	/^  int n;                \/* Number of features in the signature *\/$/;"	m	struct:__anon1	access:public
_averageColor	segment2d.h	/^            typename T::MeasureColorType _averageColor;$/;"	m	struct:Segment2D::Region2D	access:public
_averageColor	segment3d.h	/^    typename T::MeasureColorType _averageColor;$/;"	m	struct:Region3D_	access:public
_b	component.h	/^        T _b;$/;"	m	class:WeightEdge	access:public
_boundary	segment2d.h	/^            std::vector<T*> _boundary;$/;"	m	struct:Segment2D::Region2D	access:public
_boundary	segment3d.h	/^    std::vector<T*> _boundary;$/;"	m	struct:Region3D_	access:public
_btree	triangulate.h	/^        BinaryTree *_btree;$/;"	m	class:FindComponents	access:public
_centerIds	cluster_node.h	/^        std::list<int> _centerIds;            \/\/!< id of center points $/;"	m	class:ClusterNode	access:public
_centroid	segment2d.h	/^            PointF  _centroid;$/;"	m	struct:Segment2D::Region2D	access:public
_centroid	segment3d.h	/^    PointF3D  _centroid;$/;"	m	struct:Region3D_	access:public
_cloud	cluster_node.cpp	/^pcl::PointCloud<PointT>::Ptr ClusterNode::_cloud;$/;"	m	class:ClusterNode	file:
_cloud	cluster_node.h	/^        static pcl::PointCloud<PointT>::Ptr _cloud;$/;"	m	class:ClusterNode	access:private
_cloud	vizblockworld.h	/^        pcl::PointCloud<PointT>::Ptr _cloud;$/;"	m	class:VizBlockWorld	access:private
_color	pixel.h	/^        GrayColor _color;$/;"	m	class:GrayPixel2D	access:public
_color	pixel.h	/^        GrayColor _color;$/;"	m	class:GrayPixel3D	access:protected
_color	pixel.h	/^        RgbColor _color;$/;"	m	class:RgbPixel2D	access:public
_color	pixel.h	/^        RgbColor _color;$/;"	m	class:RgbPixel3D	access:public
_color	triangulate.h	/^    m_opencv::RgbColor _color;$/;"	m	struct:ComponentsInfo	access:public
_colorGenerator	triangulate.h	/^        m_opencv::RandomColor _colorGenerator;$/;"	m	class:MyTriangulation	access:private
_comp	segment2d.h	/^            Component2D *_comp;$/;"	m	struct:Segment2D::Region2D	access:public
_comp	segment3d.h	/^    Component<T*> *_comp;$/;"	m	struct:Region3D_	access:public
_compInfo	triangulate.h	/^        ComponentsInfo *_compInfo;$/;"	m	class:FindComponents	access:public
_components	segment2d.h	/^        std::vector<Component2D> _components;$/;"	m	class:Segment2D	access:private
_components	segment3d.h	/^        std::list<Component3D> _components;$/;"	m	class:Segment3D	access:private
_currentNode	cluster_node.cpp	/^TrNode BinaryTree::_currentNode;$/;"	m	class:BinaryTree	file:
_currentNode	cluster_node.h	/^        static TrNode _currentNode;$/;"	m	class:BinaryTree	access:public
_dMatrix	graph.h	/^    MatrixGraph _dMatrix;                        \/\/!< distance matrix $/;"	m	class:m_graph::GraphUtil	access:public
_e	component.h	/^        T _e;$/;"	m	class:WeightEdge	access:public
_edge_weight	segment2d.h	/^        double _edge_weight(const T &a, const T &b){ return T::density_distance(a,b) ;}$/;"	f	class:Segment2D	access:protected	signature:(const T &a, const T &b)
_edge_weight	segment3d.h	/^        double _edge_weight(const T &a, const T &b){ return T::density_distance(a,b) ;}$/;"	f	class:Segment3D	access:protected	signature:(const T &a, const T &b)
_extract_model	segment2d.h	/^        void _extract_model(int noise = 1);$/;"	p	class:Segment2D	access:protected	signature:(int noise = 1)
_extract_model	segment2d.h	/^void Segment2D<T>::_extract_model(int noise){$/;"	f	class:Segment2D	signature:(int noise)
_extract_model	segment3d.h	/^        void _extract_model(int noise);$/;"	p	class:Segment3D	access:public	signature:(int noise)
_extract_model	segment3d.h	/^void Segment3D<T>::_extract_model(int noise){$/;"	f	class:Segment3D	signature:(int noise)
_feature_neighbors	pixelworld3d.h	/^        std::vector<T*> _feature_neighbors(const T &t) const{ };$/;"	f	class:PixelWorld3D	access:protected	signature:(const T &t) const
_feature_neighbors	segment2d.h	/^        std::vector<T*> _feature_neighbors(const T &t) const;$/;"	p	class:Segment2D	access:protected	signature:(const T &t) const
_feature_neighbors	segment2d.h	/^std::vector<T*> Segment2D<T>::_feature_neighbors(const T &t) const{$/;"	f	class:Segment2D	signature:(const T &t) const
_g	graph.h	/^        GraphContainer _g;$/;"	m	class:m_graph::BaseGraph	access:protected
_g	graph.h	/^    Graph *_g;                              \/\/!< the graph $/;"	m	class:m_graph::GraphUtil	access:private
_gaussian	segment2d.h	/^        void _gaussian(){ }$/;"	f	class:Segment2D	access:protected	signature:()
_gaussian	segment3d.h	/^        void _gaussian(){ }$/;"	f	class:Segment3D	access:protected	signature:()
_grid_neighbors	pixelworld3d.h	/^        std::vector<T*> _grid_neighbors(const T &t) const;$/;"	p	class:PixelWorld3D	access:protected	signature:(const T &t) const
_grid_neighbors	pixelworld3d.h	/^inline std::vector<T*> PixelWorld3D<T>::_grid_neighbors(const T &t) const{$/;"	f	class:PixelWorld3D	signature:(const T &t) const
_grid_neighbors	segment2d.h	/^        std::vector<T*> _grid_neighbors(const T &t) const;$/;"	p	class:Segment2D	access:protected	signature:(const T &t) const
_grid_neighbors	segment2d.h	/^inline std::vector<T*> Segment2D<T>::_grid_neighbors(const T &t) const{$/;"	f	class:Segment2D	signature:(const T &t) const
_height	pixelworld2d.h	/^        int             _height;$/;"	m	class:PixelWorld2D	access:protected
_id2nodeIdPairPtr	graph.h	/^            _id2nodeIdPairPtr;$/;"	m	class:m_graph::AutoUniGraph	access:private
_if_merge	component.h	/^        inline static bool _if_merge(double comp_diff, const Component &a, const Component &b) {$/;"	f	class:Component	access:public	signature:(double comp_diff, const Component &a, const Component &b)
_image	pixelworld2d.h	/^        typename T::ImageType _image;$/;"	m	class:PixelWorld2D	access:protected
_imgModel	segment2d.h	/^        ImageModel _imgModel;$/;"	m	class:Segment2D	access:private
_imgModel	segment3d.h	/^        ImageModel &_imgModel;$/;"	m	class:SegMethod	access:private
_imgModel	segment3d.h	/^        ImageModel _imgModel;$/;"	m	class:Segment3D	access:private
_inStack	cluster_node.h	/^        std::stack<NodeId> _inStack;$/;"	m	class:BinaryTree	access:public
_isGrid	pixelworld3d.h	/^        bool            _isGrid;$/;"	m	class:PixelWorld3D	access:protected
_isGrid	segment2d.h	/^        bool            _isGrid;$/;"	m	class:Segment2D	access:private
_is_inside	segment2d.h	/^        bool _is_inside(int x, int y) const;$/;"	p	class:Segment2D	access:protected	signature:(int x, int y) const
_is_inside	segment2d.h	/^inline bool Segment2D<T>::_is_inside(int x, int y) const{$/;"	f	class:Segment2D	signature:(int x, int y) const
_leafs	triangulate.h	/^    std::vector<BinaryTree::NodeId> _leafs;$/;"	m	struct:ComponentsInfo	access:public
_luvColor	pixel.h	/^        LuvColor _luvColor;$/;"	m	class:RgbPixel2D	access:public
_luvColor	pixel.h	/^        LuvColor _luvColor;$/;"	m	class:RgbPixel3D	access:public
_maxC	emd.cpp	/^static float _maxC;$/;"	v	file:
_maxW	emd.cpp	/^static double _maxW;$/;"	v	file:
_max_weight	component.h	/^        double _max_weight;$/;"	m	class:Component	access:private
_members	component.h	/^        std::set<T> _members;$/;"	m	class:Component	access:private
_n1	emd.cpp	/^static int _n1, _n2;                          \/* SIGNATURES SIZES *\/$/;"	v	file:
_n2	emd.cpp	/^static int _n1, _n2;                          \/* SIGNATURES SIZES *\/$/;"	v	file:
_next	component.h	/^        Component *_next;$/;"	m	class:Component	access:public
_node2id	graph.h	/^        typename std::map<Node, NodeId> _node2id;$/;"	m	class:m_graph::AutoUniGraph	access:private
_noises	segment2d.h	/^        std::set<Component2D> _noises;$/;"	m	class:Segment2D	access:private
_noises	segment3d.h	/^        std::set<Component3D> _noises;$/;"	m	class:Segment3D	access:private
_num_components	triangulate.h	/^    int _num_components;$/;"	m	struct:ComponentsInfo	access:public
_objId	vizblockworld.h	/^        int _objId;$/;"	m	class:VizBlockWorld	access:private
_optimze_model	segment2d.h	/^        void _optimze_model(int scale );$/;"	p	class:Segment2D	access:protected	signature:(int scale )
_optimze_model	segment2d.h	/^void Segment2D<T>::_optimze_model(int scale){$/;"	f	class:Segment2D	signature:(int scale)
_outStack	cluster_node.h	/^        std::stack<NodeId> _outStack;           \/\/ could replace stack with vector $/;"	m	class:BinaryTree	access:public
_parent	pixel.h	/^        Component<GrayPixel2D*> *_parent;$/;"	m	class:GrayPixel2D	access:public
_parent	pixel.h	/^        Component<GrayPixel3D*> *_parent;$/;"	m	class:GrayPixel3D	access:public
_parent	pixel.h	/^        Component<RgbPixel2D*> *_parent;$/;"	m	class:RgbPixel2D	access:public
_parent	pixel.h	/^        Component<RgbPixel3D*> *_parent;$/;"	m	class:RgbPixel3D	access:public
_pixels	pixelworld2d.h	/^        T        **_pixels;    $/;"	m	class:PixelWorld2D	access:protected
_pixels	pixelworld3d.h	/^        PixelSet     _pixels;    $/;"	m	class:PixelWorld3D	access:protected
_pixels	util.h	/^        const std::set<T> &_pixels;$/;"	m	class:OriginMethod	access:private
_regionColor	segment2d.h	/^            m_opencv::RgbColor  _regionColor;$/;"	m	struct:Segment2D::Region2D	access:public
_regionColor	segment3d.h	/^    m_opencv::RgbColor  _regionColor;$/;"	m	struct:Region3D_	access:public
_rst	segment3d.h	/^        xmlrpc_c::value _rst;$/;"	m	class:SegMethod	access:private
_rst	util.h	/^        xmlrpc_c::value _rst;$/;"	m	class:OriginMethod	access:private
_s	triangulate.h	/^        bool _s;$/;"	m	class:MyTriangulation	access:private
_scale	segment2d.h	/^            int _scale;$/;"	m	struct:Segment2D::Filter	access:public
_size	pixel.h	/^        int _size;$/;"	m	class:GrayPixel3D	access:public
_size	pixel.h	/^        int _size;$/;"	m	class:RgbPixel3D	access:public
_temp	pixelworld2d.h	/^        IplImage* _temp;$/;"	m	class:PixelWorld2D	access:protected
_triangles	triangulate.h	/^        std::vector<Triangle*> *_triangles;$/;"	m	class:TrianglesOfComponent	access:public
_viewer	vizblockworld.h	/^        pcl::visualization::PCLVisualizer *_viewer;$/;"	m	class:VizBlockWorld	access:private
_viz	triangulate.h	/^        VizBlockWorld *_viz;$/;"	m	class:MyTriangulation	access:private
_vizIds	triangulate.h	/^        std::stack<std::string> _vizIds; \/\/!< store id of components in visualizer$/;"	m	class:MyTriangulation	access:private
_weight	component.h	/^        double _weight;$/;"	m	class:WeightEdge	access:public
_width	pixelworld2d.h	/^        int             _width;$/;"	m	class:PixelWorld2D	access:protected
_x	pixel.h	/^        float _x;$/;"	m	class:GrayPixel3D	access:public
_x	pixel.h	/^        float _x;$/;"	m	class:RgbPixel3D	access:public
_x	pixel.h	/^        int _x;$/;"	m	class:GrayPixel2D	access:public
_x	pixel.h	/^        int _x;$/;"	m	class:RgbPixel2D	access:public
_x_offset	vizblockworld.h	/^        float _x_offset;$/;"	m	class:VizBlockWorld	access:private
_y	pixel.h	/^        float _y;$/;"	m	class:GrayPixel3D	access:public
_y	pixel.h	/^        float _y;$/;"	m	class:RgbPixel3D	access:public
_y	pixel.h	/^        int _y;$/;"	m	class:GrayPixel2D	access:public
_y	pixel.h	/^        int _y;$/;"	m	class:RgbPixel2D	access:public
_y_offset	vizblockworld.h	/^        float _y_offset;$/;"	m	class:VizBlockWorld	access:private
_z	pixel.h	/^        float _z;$/;"	m	class:GrayPixel3D	access:public
_z	pixel.h	/^        float _z;$/;"	m	class:RgbPixel3D	access:public
_z_offset	vizblockworld.h	/^        float _z_offset;$/;"	m	class:VizBlockWorld	access:private
addBasicVariable	emd.cpp	/^static void addBasicVariable(int minI, int minJ, double *S, double *D, $/;"	f	file:	signature:(int minI, int minJ, double *S, double *D, node1_t *PrevUMinI, node1_t *PrevVMinJ, node1_t *UHead)
addBasicVariable	emd.cpp	/^static void addBasicVariable(int minI, int minJ, double *S, double *D, $/;"	p	file:	signature:(int minI, int minJ, double *S, double *D, node1_t *PrevUMinI, node1_t *PrevVMinJ, node1_t *UHead)
add_cloud	vizblockworld.h	/^        std::string add_cloud(const pcl::PointCloud<PointT>::Ptr cloud, int viewport = 0, int pointSize = 1){$/;"	f	class:VizBlockWorld	access:public	signature:(const pcl::PointCloud<PointT>::Ptr cloud, int viewport = 0, int pointSize = 1)
add_cube	vizblockworld.h	/^        std::string add_cube(float x, float y, float z, int r, int g, int b, int viewport = 0, float cubeSize = 1, int STYLE = 1){$/;"	f	class:VizBlockWorld	access:public	signature:(float x, float y, float z, int r, int g, int b, int viewport = 0, float cubeSize = 1, int STYLE = 1)
add_cylinder	vizblockworld.h	/^        std::string add_cylinder(double centerX, double centerY, double centerZ, double normalX,$/;"	f	class:VizBlockWorld	access:public	signature:(double centerX, double centerY, double centerZ, double normalX, double normalY, double normalZ, double radius, int viewport = 0)
add_edge	graph.h	/^            add_edge(const NodeId& source, const NodeId& target)$/;"	f	class:m_graph::BaseGraph	access:public	signature:(const NodeId& source, const NodeId& target)
add_line	vizblockworld.h	/^        std::string add_line(double aX, double aY, double aZ, $/;"	f	class:VizBlockWorld	access:public	signature:(double aX, double aY, double aZ, double bX, double bY, double bZ, int r, int g, int b, int viewport = 0)
add_line	vizblockworld.h	/^        std::string add_line(double aX, double aY, double aZ, $/;"	f	class:VizBlockWorld	access:public	signature:(double aX, double aY, double aZ, double bX, double bY, double bZ, int viewport = 0)
add_member	component.h	/^        inline void add_member(T elem){$/;"	f	class:Component	access:public	signature:(T elem)
add_mesh	vizblockworld.h	/^        std::string  add_mesh(const pcl::PolygonMesh *mesh, int viewport = 0){$/;"	f	class:VizBlockWorld	access:public	signature:(const pcl::PolygonMesh *mesh, int viewport = 0)
add_node	graph.h	/^        inline NodeId add_node() {$/;"	f	class:m_graph::BaseGraph	access:public	signature:()
add_node	graph.h	/^        inline NodeId add_node(const Node& node) {$/;"	f	class:m_graph::AutoUniGraph	access:public	signature:(const Node& node)
add_node	graph.h	/^        inline NodeId add_node(const Node& node) {$/;"	f	class:m_graph::ManualUniGraph	access:public	signature:(const Node& node)
add_plane	vizblockworld.h	/^        std::string add_plane(double a, double b, double c, double d, int viewport = 0){$/;"	f	class:VizBlockWorld	access:public	signature:(double a, double b, double c, double d, int viewport = 0)
add_plane	vizblockworld.h	/^        std::string add_plane(double px, double py, double pz, double normalX, double normalY, double normalZ, int viewport = 0){$/;"	f	class:VizBlockWorld	access:public	signature:(double px, double py, double pz, double normalX, double normalY, double normalZ, int viewport = 0)
add_point	vizblockworld.h	/^        inline void  add_point(float x, float y, float z, int r, int g, int b, float unit = 1){ $/;"	f	class:VizBlockWorld	access:public	signature:(float x, float y, float z, int r, int g, int b, float unit = 1)
add_point	vizblockworld.h	/^        inline void add_point(const PointT &p, int r, int g, int b, float unit = 1){$/;"	f	class:VizBlockWorld	access:public	signature:(const PointT &p, int r, int g, int b, float unit = 1)
add_sphere	vizblockworld.h	/^        std::string add_sphere(double centerX, double centerY, double centerZ, double radius, $/;"	f	class:VizBlockWorld	access:public	signature:(double centerX, double centerY, double centerZ, double radius, int r, int g, int b, int viewport = 0)
add_sphere	vizblockworld.h	/^        std::string add_sphere(double centerX, double centerY, double centerZ, double radius, int viewport = 0){$/;"	f	class:VizBlockWorld	access:public	signature:(double centerX, double centerY, double centerZ, double radius, int viewport = 0)
add_text	vizblockworld.h	/^        std::string add_text(const std::string &text, int x, int y, int viewport = 0){$/;"	f	class:VizBlockWorld	access:public	signature:(const std::string &text, int x, int y, int viewport = 0)
add_text3D	vizblockworld.h	/^        std::string add_text3D(const std::string &text, float x, float y, float z, $/;"	f	class:VizBlockWorld	access:public	signature:(const std::string &text, float x, float y, float z, int r, int g, int b, double scale = 1.0, int viewport = 0)
amount	emd.h	/^  float amount;         \/* Amount of flow from "from" to "to" *\/$/;"	m	struct:flow_t	access:public
areas	cluster_node.h	/^        List areas;            \/\/!< Triangle areas$/;"	m	class:ClusterNode	access:public
bestFittingCircle	cluster_node.cpp	/^bool ClusterNode::bestFittingCircle(double *pts, int numpts, double& x0, double &y0, double& r)$/;"	f	class:ClusterNode	signature:(double *pts, int numpts, double& x0, double &y0, double& r)
bestFittingCircle	cluster_node.h	/^        static bool bestFittingCircle(double *, int, double&, double&, double&);$/;"	p	class:ClusterNode	access:public	signature:(double *, int, double&, double&, double&)
bestFittingSphere	cluster_node.cpp	/^bool ClusterNode::bestFittingSphere(SymMatrix4x4& AtA, double *Atb, double& x0, double &y0, double &z0, double& r)$/;"	f	class:ClusterNode	signature:(SymMatrix4x4& AtA, double *Atb, double& x0, double &y0, double &z0, double& r)
bestFittingSphere	cluster_node.h	/^        static bool bestFittingSphere(SymMatrix4x4&, double *, double&, double&, double&, double&);$/;"	p	class:ClusterNode	access:public	signature:(SymMatrix4x4&, double *, double&, double&, double&, double&)
boost	graph.h	/^namespace boost {$/;"	n
boost::BOOST_INSTALL_PROPERTY	graph.h	/^    BOOST_INSTALL_PROPERTY(vertex, node);$/;"	p	namespace:boost	signature:(vertex, node)
boostGraph	cluster_node.h	/^typedef adjacency_list<setS, vecS, bidirectionalS, no_property, property<edge_weight_t, int> > boostGraph;$/;"	t
boostGraph2	triangulate.h	/^        typedef adjacency_list<vecS, vecS, undirectedS, no_property, property<edge_weight_t, int> > boostGraph2;$/;"	t	class:MyTriangulation	access:protected
brotherId	cluster_node.h	/^        NodeId brotherId(NodeId id){$/;"	f	class:BinaryTree	access:public	signature:(NodeId id)
camera_info	vizblockworld.h	/^inline void camera_info(pcl::visualization::Camera &camera)$/;"	f	signature:(pcl::visualization::Camera &camera)
change_color	triangulate.cpp	/^void MyTriangulation::change_color(){$/;"	f	class:MyTriangulation	signature:()
change_color	triangulate.h	/^        void change_color();$/;"	p	class:MyTriangulation	access:public	signature:()
childId	cluster_node.h	/^        int childId;$/;"	m	class:ClusterNode	access:public
childrenId	cluster_node.h	/^        std::pair<NodeId, NodeId> childrenId(NodeId p){$/;"	f	class:BinaryTree	access:public	signature:(NodeId p)
clear	component.h	/^        inline void clear(){$/;"	f	class:Component	access:public	signature:()
clear	graph.h	/^        inline void clear()$/;"	f	class:m_graph::BaseGraph	access:public	signature:()
clear	triangulate.h	/^    void clear(){$/;"	f	struct:ComponentsInfo	access:public	signature:()
clear	vizblockworld.h	/^        void clear(int viewport = 0){$/;"	f	class:VizBlockWorld	access:public	signature:(int viewport = 0)
clear_	graph.h	/^        virtual void clear_(){ }$/;"	f	class:m_graph::BaseGraph	access:public	signature:()
clear_	graph.h	/^        virtual void clear_(){$/;"	f	class:m_graph::AutoUniGraph	access:public	signature:()
cluster	cluster_node.cpp	/^BinaryTree& ClusterNode::cluster(MyTriangulation *tin){$/;"	f	class:ClusterNode	signature:(MyTriangulation *tin)
cluster	cluster_node.h	/^        static BinaryTree &cluster(MyTriangulation *tin);$/;"	p	class:ClusterNode	access:public	signature:(MyTriangulation *tin)
cluster_points	vizblockworld.cpp	/^void cluster_points(const pcl::PointCloud<PointT>::Ptr cloud, CloudVector *clusters){$/;"	f	signature:(const pcl::PointCloud<PointT>::Ptr cloud, CloudVector *clusters)
cluster_points	vizblockworld.h	/^void cluster_points(const pcl::PointCloud<PointT>::Ptr cloud, CloudVector *clusters);$/;"	p	signature:(const pcl::PointCloud<PointT>::Ptr cloud, CloudVector *clusters)
coef1	cluster_node.cpp	/^Coefficient ClusterNode::coef1;$/;"	m	class:ClusterNode	file:
coef1	cluster_node.h	/^        static Coefficient coef1;$/;"	m	class:ClusterNode	access:public
coef2	cluster_node.cpp	/^Coefficient ClusterNode::coef2;$/;"	m	class:ClusterNode	file:
coef2	cluster_node.h	/^        static Coefficient coef2;$/;"	m	class:ClusterNode	access:public
coef3	cluster_node.cpp	/^Coefficient ClusterNode::coef3;$/;"	m	class:ClusterNode	file:
coef3	cluster_node.h	/^        static Coefficient coef3;$/;"	m	class:ClusterNode	access:public
coefficient	cluster_node.h	/^    Coefficient coefficient;$/;"	m	struct:TrNode	access:public
components	main.cpp	/^std::vector<pcl::PointCloud<PointT>::Ptr> components;$/;"	v
components_color	util.cpp	/^std::vector<RgbColor>& components_color( ){$/;"	f	signature:( )
computeTransformation	icp.h	/^      computeTransformation (PointCloudSource &output, const Eigen::Matrix4f &guess);$/;"	p	class:IterativeClosestPoint	access:protected	signature:(PointCloudSource &output, const Eigen::Matrix4f &guess)
contain_node	graph.h	/^        inline bool contain_node(const Node& node){$/;"	f	class:m_graph::AutoUniGraph	access:public	signature:(const Node& node)
contains	component.h	/^        inline bool contains(T pixel) const{$/;"	f	class:Component	access:public	signature:(T pixel) const
cost	cluster_node.h	/^    double cost;$/;"	m	struct:TrNode	access:public
cost0	cluster_node.h	/^    double cost0;$/;"	m	struct:TrNode	access:public
cost1	cluster_node.h	/^    double cost1;$/;"	m	struct:TrNode	access:public
cost2	cluster_node.h	/^    double cost2;$/;"	m	struct:TrNode	access:public
create_h_viewport	vizblockworld.h	/^        void create_h_viewport(int &v1, int &v2){$/;"	f	class:VizBlockWorld	access:public	signature:(int &v1, int &v2)
create_matrix	graph.h	/^    inline void create_matrix(){$/;"	f	class:m_graph::GraphUtil	access:public	signature:()
create_point	vizblockworld.h	/^inline PointT create_point(float x, float y, float z, int r, int g, int b){$/;"	f	signature:(float x, float y, float z, int r, int g, int b)
create_v_viewport	vizblockworld.h	/^        void create_v_viewport(int &v1, int &v2){$/;"	f	class:VizBlockWorld	access:public	signature:(int &v1, int &v2)
create_viewport	vizblockworld.h	/^        void create_viewport(float xmin, float ymin, float xmax, float ymax, int &viewport){$/;"	f	class:VizBlockWorld	access:public	signature:(float xmin, float ymin, float xmax, float ymax, int &viewport)
create_viewport_camera	vizblockworld.h	/^        void create_viewport_camera(int view){$/;"	f	class:VizBlockWorld	access:public	signature:(int view)
defaultCoef	cluster_node.h	/^    static Coefficient defaultCoef;$/;"	m	struct:TrNode	access:public
density_distance	pixel.h	/^        static double density_distance(const GrayPixel2D &a, const GrayPixel2D &b){$/;"	f	class:GrayPixel2D	access:public	signature:(const GrayPixel2D &a, const GrayPixel2D &b)
density_distance	pixel.h	/^        static double density_distance(const GrayPixel3D &a, const GrayPixel3D &b){$/;"	f	class:GrayPixel3D	access:public	signature:(const GrayPixel3D &a, const GrayPixel3D &b)
density_distance	pixel.h	/^        static double density_distance(const RgbPixel2D &a, const RgbPixel2D &b){$/;"	f	class:RgbPixel2D	access:public	signature:(const RgbPixel2D &a, const RgbPixel2D &b)
density_distance	pixel.h	/^        static double density_distance(const RgbPixel3D &a, const RgbPixel3D &b){$/;"	f	class:RgbPixel3D	access:public	signature:(const RgbPixel3D &a, const RgbPixel3D &b)
direction	cluster_node.h	/^    Point direction;                            \/\/!< normal or axis $/;"	m	struct:Coefficient	access:public
discover_vertex	triangulate.h	/^            void discover_vertex(Vertex u, const Graph & g) const$/;"	f	class:TrianglesOfComponent	access:public	signature:(Vertex u, const Graph & g) const
discover_vertex	triangulate.h	/^            void discover_vertex(Vertex u, const Graph & g)$/;"	f	class:FindComponents	access:public	signature:(Vertex u, const Graph & g)
display	vizblockworld.cpp	/^void VizBlockWorld::display(){$/;"	f	class:VizBlockWorld	signature:()
display	vizblockworld.cpp	/^void VizBlockWorld::display(std::vector<pcl::visualization::PCLVisualizer*> viewers){$/;"	f	class:VizBlockWorld	signature:(std::vector<pcl::visualization::PCLVisualizer*> viewers)
display	vizblockworld.h	/^        static void display(std::vector<pcl::visualization::PCLVisualizer*> viewers);$/;"	p	class:VizBlockWorld	access:public	signature:(std::vector<pcl::visualization::PCLVisualizer*> viewers)
display	vizblockworld.h	/^        void display();$/;"	p	class:VizBlockWorld	access:public	signature:()
down_samples	vizblockworld.cpp	/^PointCloudPtr down_samples(PointCloudPtr input){$/;"	f	signature:(PointCloudPtr input)
down_samples	vizblockworld.h	/^PointCloudPtr down_samples(PointCloudPtr input);$/;"	p	signature:(PointCloudPtr input)
draw	vizblockworld.h	/^        void draw(){ _viewer->initCameraParameters (); }$/;"	f	class:VizBlockWorld	access:public	signature:()
dynamic_EMD	triangulate.cpp	/^MyTriangulation::dynamic_EMD(PointCloudPtr target, PointCloudPtr source,$/;"	f	class:MyTriangulation	signature:(PointCloudPtr target, PointCloudPtr source, const vector<float> &wInput, const vector<float> &wOutput)
dynamic_EMD	triangulate.h	/^        void dynamic_EMD(PointCloudPtr target, PointCloudPtr source,$/;"	p	class:MyTriangulation	access:public	signature:(PointCloudPtr target, PointCloudPtr source, const vector<float> &wInput, const vector<float> &wOutput)
edgeCostFunction	cluster_node.cpp	/^double ClusterNode::edgeCostFunction(const void *cn1, const void *cn2)$/;"	f	class:ClusterNode	signature:(const void *cn1, const void *cn2)
edgeCostFunction	cluster_node.h	/^        static double edgeCostFunction(const void *n1, const void *n2);$/;"	p	class:ClusterNode	access:public	signature:(const void *n1, const void *n2)
edgeInfo	cluster_node.cpp	/^std::unordered_set<TrNode,boost::hash<TrNode>> ClusterNode::edgeInfo;$/;"	m	class:ClusterNode	file:
edgeInfo	cluster_node.h	/^        static std::unordered_set<TrNode,boost::hash<TrNode>> edgeInfo;$/;"	m	class:ClusterNode	access:private
edge_weights	graph.h	/^        inline EdgeWeightsMap edge_weights() {$/;"	f	class:m_graph::BaseGraph	access:public	signature:()
edge_weights	graph.h	/^        inline const EdgeWeightsMap edge_weights() const{$/;"	f	class:m_graph::BaseGraph	access:public	signature:() const
emd	emd.cpp	/^float emd(signature_t *Signature1, signature_t *Signature2,$/;"	f	signature:(signature_t *Signature1, signature_t *Signature2, float (*Dist)(feature_t *, feature_t *), flow_t *Flow, int *FlowSize)
emd	emd.h	/^float emd(signature_t *Signature1, signature_t *Signature2,$/;"	p	signature:(signature_t *Signature1, signature_t *Signature2, float (*func)(feature_t *, feature_t *), flow_t *Flow, int *FlowSize)
emd_wapper	emd.cpp	/^float emd_wapper(const Features &supplier, const std::vector<float> sWeight,$/;"	f	signature:(const Features &supplier, const std::vector<float> sWeight, const Features &demand, const std::vector<float> dWeight, flow_t *flow, float (*dist_fun)(feature_t *F1, feature_t *F2), VizBlockWorld *viz, float radius )
emd_wapper	emd.h	/^float emd_wapper(const Features &supplier, const std::vector<float> sWeight,$/;"	p	signature:(const Features &supplier, const std::vector<float> sWeight, const Features &demand, const std::vector<float> dWeight, flow_t *flow, float (*dist_fun)(feature_t *F1, feature_t *F2), VizBlockWorld *viz = NULL, float radius = 0.1 )
execute	segment3d.h	/^        void execute(xmlrpc_c::paramList const& paramList,$/;"	f	class:SegMethod	access:public	signature:(xmlrpc_c::paramList const& paramList, xmlrpc_c::value * const retvalP)
execute	util.h	/^        void execute(xmlrpc_c::paramList const& paramList,$/;"	f	class:OriginMethod	access:public	signature:(xmlrpc_c::paramList const& paramList, xmlrpc_c::value * const retvalP)
feature_t	emd.h	/^typedef pcl::PointXYZRGB feature_t;$/;"	t
filter	segment2d.h	/^        void filter(int noise = 1);$/;"	p	class:Segment2D	access:public	signature:(int noise = 1)
filter	segment2d.h	/^void Segment2D<T>::filter(int noise){$/;"	f	class:Segment2D	signature:(int noise)
findBasicVariables	emd.cpp	/^static void findBasicVariables(node1_t *U, node1_t *V)$/;"	f	file:	signature:(node1_t *U, node1_t *V)
findBasicVariables	emd.cpp	/^static void findBasicVariables(node1_t *U, node1_t *V);$/;"	p	file:	signature:(node1_t *U, node1_t *V)
findLoop	emd.cpp	/^static int findLoop(node2_t **Loop)$/;"	f	file:	signature:(node2_t **Loop)
findLoop	emd.cpp	/^static int findLoop(node2_t **Loop);$/;"	p	file:	signature:(node2_t **Loop)
fittingCylinderCost	cluster_node.cpp	/^double ClusterNode::fittingCylinderCost(const void *cn1, const void *cn2)$/;"	f	class:ClusterNode	signature:(const void *cn1, const void *cn2)
fittingCylinderCost	cluster_node.h	/^        static double fittingCylinderCost(const void *, const void *);$/;"	p	class:ClusterNode	access:public	signature:(const void *, const void *)
fittingPlaneCost	cluster_node.cpp	/^double ClusterNode::fittingPlaneCost(const void *cn1, const void *cn2)$/;"	f	class:ClusterNode	signature:(const void *cn1, const void *cn2)
fittingPlaneCost	cluster_node.h	/^        static double fittingPlaneCost(const void *, const void *);$/;"	p	class:ClusterNode	access:public	signature:(const void *, const void *)
fittingSphereCost	cluster_node.cpp	/^double ClusterNode::fittingSphereCost(const void *cn1, const void *cn2)$/;"	f	class:ClusterNode	signature:(const void *cn1, const void *cn2)
fittingSphereCost	cluster_node.h	/^        static double fittingSphereCost(const void *, const void *);$/;"	p	class:ClusterNode	access:public	signature:(const void *, const void *)
flow_t	emd.h	/^  flow_t():from(0), to(0), amount(0){ }$/;"	f	struct:flow_t	access:public	signature:()
flow_t	emd.h	/^struct flow_t$/;"	s
flow_t::amount	emd.h	/^  float amount;         \/* Amount of flow from "from" to "to" *\/$/;"	m	struct:flow_t	access:public
flow_t::flow_t	emd.h	/^  flow_t():from(0), to(0), amount(0){ }$/;"	f	struct:flow_t	access:public	signature:()
flow_t::from	emd.h	/^  int from;             \/* Feature number in signature 1 *\/$/;"	m	struct:flow_t	access:public
flow_t::operator <	emd.h	/^  bool operator < (const flow_t &other) const{$/;"	f	struct:flow_t	access:public	signature:(const flow_t &other) const
flow_t::to	emd.h	/^  int to;               \/* Feature number in signature 2 *\/$/;"	m	struct:flow_t	access:public
friendId	cluster_node.h	/^    int friendId;$/;"	m	struct:TrNode	access:public
from	emd.h	/^  int from;             \/* Feature number in signature 1 *\/$/;"	m	struct:flow_t	access:public
gId2treeId	cluster_node.cpp	/^std::unordered_map<int, int> ClusterNode::gId2treeId;$/;"	m	class:ClusterNode	file:
gId2treeId	cluster_node.h	/^        static std::unordered_map<int, int> gId2treeId;$/;"	m	class:ClusterNode	access:private
generte_mesh	vizblockworld.cpp	/^void VizBlockWorld::generte_mesh(const pcl::PointCloud<pcl::PointXYZ>::Ptr cloud, pcl::PolygonMesh *triangles){$/;"	f	class:VizBlockWorld	signature:(const pcl::PointCloud<pcl::PointXYZ>::Ptr cloud, pcl::PolygonMesh *triangles)
generte_mesh	vizblockworld.h	/^        void generte_mesh(pcl::PointCloud<pcl::PointXYZ>::Ptr cloud, pcl::PolygonMesh *triangles);$/;"	p	class:VizBlockWorld	access:public	signature:(pcl::PointCloud<pcl::PointXYZ>::Ptr cloud, pcl::PolygonMesh *triangles)
geometry_weight	cluster_node.h	/^    static double geometry_weight(const TrNode &node){$/;"	f	struct:TrNode	access:public	signature:(const TrNode &node)
get_adj_nodes	graph.h	/^        inline AdjRange get_adj_nodes(const NodeId& id) const$/;"	f	class:m_graph::BaseGraph	access:public	signature:(const NodeId& id) const
get_all_edges	graph.h	/^        inline EdgeRange get_all_edges() const{$/;"	f	class:m_graph::BaseGraph	access:public	signature:() const
get_all_nodes	graph.h	/^        inline NodeRange get_all_nodes() const$/;"	f	class:m_graph::BaseGraph	access:public	signature:() const
get_color	pixel.h	/^        GrayColor  get_color() const{$/;"	f	class:GrayPixel3D	access:public	signature:() const
get_color	pixel.h	/^        RgbColor  get_color() const{$/;"	f	class:RgbPixel3D	access:public	signature:() const
get_color	pixel.h	/^        const GrayColor&  get_color() const{$/;"	f	class:GrayPixel2D	access:public	signature:() const
get_color	pixel.h	/^        const RgbColor&  get_color() const{$/;"	f	class:RgbPixel2D	access:public	signature:() const
get_container	graph.h	/^        inline GraphContainer& get_container() $/;"	f	class:m_graph::BaseGraph	access:public	signature:()
get_container	graph.h	/^        inline const GraphContainer& get_container() const$/;"	f	class:m_graph::BaseGraph	access:public	signature:() const
get_correspondence	icp.h	/^      const BiMap& get_correspondence() const{$/;"	f	class:IterativeClosestPoint	access:public	signature:() const
get_degree	graph.h	/^        inline int get_degree(const NodeId& id) const$/;"	f	class:m_graph::BaseGraph	access:public	signature:(const NodeId& id) const
get_density	pixel.h	/^        double get_density( ) const{$/;"	f	class:RgbPixel2D	access:public	signature:( ) const
get_density	pixel.h	/^        double get_density( ) const{$/;"	f	class:RgbPixel3D	access:public	signature:( ) const
get_density	pixel.h	/^        double get_density() const{$/;"	f	class:GrayPixel2D	access:public	signature:() const
get_density	pixel.h	/^        double get_density() const{$/;"	f	class:GrayPixel3D	access:public	signature:() const
get_edge	graph.h	/^        inline EdgePair get_edge(const EdgeId& id) const {$/;"	f	class:m_graph::BaseGraph	access:public	signature:(const EdgeId& id) const
get_in_degree	graph.h	/^        inline int get_in_degree(const NodeId& id) const$/;"	f	class:m_graph::BaseGraph	access:public	signature:(const NodeId& id) const
get_in_edges	graph.h	/^        inline InEdgeRange get_in_edges(const NodeId& id) const{$/;"	f	class:m_graph::BaseGraph	access:public	signature:(const NodeId& id) const
get_measure_color	pixel.h	/^        const GrayColor&  get_measure_color() const{$/;"	f	class:GrayPixel2D	access:public	signature:() const
get_measure_color	pixel.h	/^        const GrayColor& get_measure_color()const {$/;"	f	class:GrayPixel3D	access:public	signature:() const
get_measure_color	pixel.h	/^        const LuvColor& get_measure_color()const {$/;"	f	class:RgbPixel2D	access:public	signature:() const
get_measure_color	pixel.h	/^        const LuvColor& get_measure_color()const {$/;"	f	class:RgbPixel3D	access:public	signature:() const
get_members	component.h	/^        inline const std::set<T>& get_members() const {$/;"	f	class:Component	access:public	signature:() const
get_members	component.h	/^        inline std::set<T>& get_members(){$/;"	f	class:Component	access:public	signature:()
get_neighbors	pixelworld3d.h	/^        std::vector<T*> get_neighbors(const T &t) const;$/;"	p	class:PixelWorld3D	access:protected	signature:(const T &t) const
get_neighbors	pixelworld3d.h	/^inline std::vector<T*> PixelWorld3D<T>::get_neighbors(const T &t) const{$/;"	f	class:PixelWorld3D	signature:(const T &t) const
get_neighbors	segment2d.h	/^        std::vector<T*> get_neighbors(const T &t) const;$/;"	p	class:Segment2D	access:public	signature:(const T &t) const
get_neighbors	segment2d.h	/^inline std::vector<T*> Segment2D<T>::get_neighbors(const T &t) const{$/;"	f	class:Segment2D	signature:(const T &t) const
get_node	graph.h	/^        inline const Node& get_node(const NodeId& id) const$/;"	f	class:m_graph::AutoUniGraph	access:public	signature:(const NodeId& id) const
get_node	graph.h	/^        inline const Node& get_node(const NodeId& id)$/;"	f	class:m_graph::AutoUniGraph	access:public	signature:(const NodeId& id)
get_node	graph.h	/^        inline const Node& get_node(const NodeId& id)const$/;"	f	class:m_graph::ManualUniGraph	access:public	signature:(const NodeId& id) const
get_out_degree	graph.h	/^        inline int get_out_degree(const NodeId& id) const$/;"	f	class:m_graph::BaseGraph	access:public	signature:(const NodeId& id) const
get_out_edges	graph.h	/^        inline OutEdgeRange get_out_edges(const NodeId& id) const{$/;"	f	class:m_graph::BaseGraph	access:public	signature:(const NodeId& id) const
get_viewer	vizblockworld.h	/^        pcl::visualization::PCLVisualizer *get_viewer(){$/;"	f	class:VizBlockWorld	access:public	signature:()
hTree	triangulate.cpp	/^auto &hTree = ClusterNode::hierarchyTree;$/;"	v
hash_value	cluster_node.cpp	/^std::size_t hash_value(TrNode const &b)$/;"	f	signature:(TrNode const &b)
hash_value	cluster_node.h	/^std::size_t hash_value(TrNode const &b);$/;"	p	signature:(TrNode const &b)
hierarcStack	cluster_node.h	/^        static std::stack<BinaryTree::NodeId> hierarcStack;$/;"	m	class:ClusterNode	access:public
hierarchyTree	cluster_node.cpp	/^BinaryTree ClusterNode::hierarchyTree;$/;"	m	class:ClusterNode	file:
hierarchyTree	cluster_node.h	/^        static BinaryTree hierarchyTree;$/;"	m	class:ClusterNode	access:public
i	emd.cpp	/^    int i, j;$/;"	m	struct:node2_t	file:	access:public
i	emd.cpp	/^    int i;$/;"	m	struct:node1_t	file:	access:public
id	cluster_node.h	/^        int id;                \/\/!< Unique identifier of the node$/;"	m	class:ClusterNode	access:public
id1	cluster_node.h	/^    int id1;$/;"	m	struct:TrNode	access:public
id2	cluster_node.h	/^    int id2;$/;"	m	struct:TrNode	access:public
init	emd.cpp	/^static float init(signature_t *Signature1, signature_t *Signature2, $/;"	f	file:	signature:(signature_t *Signature1, signature_t *Signature2, float (*Dist)(feature_t *, feature_t *))
init	emd.cpp	/^static float init(signature_t *Signature1, signature_t *Signature2,$/;"	p	file:	signature:(signature_t *Signature1, signature_t *Signature2, float (*Dist)(feature_t *, feature_t *))
internal_diff	component.h	/^        inline double internal_diff() const{$/;"	f	class:Component	access:public	signature:() const
isOptimal	emd.cpp	/^static int isOptimal(node1_t *U, node1_t *V)$/;"	f	file:	signature:(node1_t *U, node1_t *V)
isOptimal	emd.cpp	/^static int isOptimal(node1_t *U, node1_t *V);$/;"	p	file:	signature:(node1_t *U, node1_t *V)
is_brother_of_out	cluster_node.h	/^        bool is_brother_of_out(NodeId t){$/;"	f	class:BinaryTree	access:public	signature:(NodeId t)
j	emd.cpp	/^    int i, j;$/;"	m	struct:node2_t	file:	access:public
johnson_all_pairs_shortest_paths	graph.h	/^    void johnson_all_pairs_shortest_paths(){$/;"	f	class:m_graph::GraphUtil	access:public	signature:()
keyboardEventOccurred	main.cpp	/^void keyboardEventOccurred (const pcl::visualization::KeyboardEvent &event,$/;"	f	signature:(const pcl::visualization::KeyboardEvent &event, void* viewer_void)
keyboardEventOccurred	util.h	/^void keyboardEventOccurred (const pcl::visualization::KeyboardEvent &event,$/;"	p	signature:(const pcl::visualization::KeyboardEvent &event, void* viewer_void)
load_mesh	triangulate.cpp	/^int MyTriangulation::load_mesh(const pcl::PointCloud<pcl::PointXYZ>::Ptr cloud, const pcl::PolygonMesh &meshes){$/;"	f	class:MyTriangulation	signature:(const pcl::PointCloud<pcl::PointXYZ>::Ptr cloud, const pcl::PolygonMesh &meshes)
load_mesh	triangulate.h	/^        int load_mesh(const pcl::PointCloud<pcl::PointXYZ>::Ptr cloud, const pcl::PolygonMesh &meshes);$/;"	p	class:MyTriangulation	access:protected	signature:(const pcl::PointCloud<pcl::PointXYZ>::Ptr cloud, const pcl::PolygonMesh &meshes)
m	component.h	/^        int m;$/;"	m	class:WeightEdge	access:public
m_graph	graph.h	/^namespace m_graph {$/;"	n
m_graph::AutoUniGraph	graph.h	/^class AutoUniGraph :public BaseGraph<GraphContainer>{$/;"	c	namespace:m_graph	inherits:BaseGraph
m_graph::AutoUniGraph::AdjIter	graph.h	/^        typedef typename BaseGraph<GraphContainer>::AdjIter AdjIter;$/;"	t	class:m_graph::AutoUniGraph	access:public
m_graph::AutoUniGraph::AdjRange	graph.h	/^        typedef std::pair<AdjIter, AdjIter> AdjRange;$/;"	t	class:m_graph::AutoUniGraph	access:public
m_graph::AutoUniGraph::AutoUniGraph	graph.h	/^        AutoUniGraph (){$/;"	f	class:m_graph::AutoUniGraph	access:public	signature:()
m_graph::AutoUniGraph::AutoUniGraph	graph.h	/^        AutoUniGraph (int numNode):BaseGraph<GraphContainer>(numNode){$/;"	f	class:m_graph::AutoUniGraph	access:public	signature:(int numNode)
m_graph::AutoUniGraph::DegreeSize	graph.h	/^        typedef typename BaseGraph<GraphContainer>::DegreeSize DegreeSize;$/;"	t	class:m_graph::AutoUniGraph	access:public
m_graph::AutoUniGraph::EdgeId	graph.h	/^        typedef typename BaseGraph<GraphContainer>::EdgeId EdgeId;$/;"	t	class:m_graph::AutoUniGraph	access:public
m_graph::AutoUniGraph::EdgeIter	graph.h	/^        typedef typename BaseGraph<GraphContainer>::EdgeIter EdgeIter;$/;"	t	class:m_graph::AutoUniGraph	access:public
m_graph::AutoUniGraph::EdgePair	graph.h	/^        typedef std::pair<NodeId, NodeId> EdgePair;$/;"	t	class:m_graph::AutoUniGraph	access:public
m_graph::AutoUniGraph::EdgeRange	graph.h	/^        typedef std::pair<EdgeIter, EdgeIter> EdgeRange;$/;"	t	class:m_graph::AutoUniGraph	access:public
m_graph::AutoUniGraph::EdgeWeightsMap	graph.h	/^        typedef typename BaseGraph<GraphContainer>::EdgeWeightsMap EdgeWeightsMap;$/;"	t	class:m_graph::AutoUniGraph	access:public
m_graph::AutoUniGraph::InEdgeIter	graph.h	/^        typedef typename BaseGraph<GraphContainer>::InEdgeIter InEdgeIter;$/;"	t	class:m_graph::AutoUniGraph	access:public
m_graph::AutoUniGraph::InEdgeRange	graph.h	/^        typedef std::pair<InEdgeIter, InEdgeIter> InEdgeRange;$/;"	t	class:m_graph::AutoUniGraph	access:public
m_graph::AutoUniGraph::NodeId	graph.h	/^        typedef typename BaseGraph<GraphContainer>::NodeId NodeId;$/;"	t	class:m_graph::AutoUniGraph	access:public
m_graph::AutoUniGraph::NodeIter	graph.h	/^        typedef typename BaseGraph<GraphContainer>::NodeIter NodeIter;$/;"	t	class:m_graph::AutoUniGraph	access:public
m_graph::AutoUniGraph::NodeRange	graph.h	/^        typedef std::pair<NodeIter, NodeIter> NodeRange;$/;"	t	class:m_graph::AutoUniGraph	access:public
m_graph::AutoUniGraph::NodeType	graph.h	/^        typedef Node NodeType;$/;"	t	class:m_graph::AutoUniGraph	access:public
m_graph::AutoUniGraph::OutEdgeIter	graph.h	/^        typedef typename BaseGraph<GraphContainer>::OutEdgeIter OutEdgeIter;$/;"	t	class:m_graph::AutoUniGraph	access:public
m_graph::AutoUniGraph::OutEdgeRange	graph.h	/^        typedef std::pair<OutEdgeIter, OutEdgeIter> OutEdgeRange;$/;"	t	class:m_graph::AutoUniGraph	access:public
m_graph::AutoUniGraph::SizeType	graph.h	/^        typedef typename BaseGraph<GraphContainer>::SizeType SizeType;$/;"	t	class:m_graph::AutoUniGraph	access:public
m_graph::AutoUniGraph::_id2nodeIdPairPtr	graph.h	/^            _id2nodeIdPairPtr;$/;"	m	class:m_graph::AutoUniGraph	access:private
m_graph::AutoUniGraph::_node2id	graph.h	/^        typename std::map<Node, NodeId> _node2id;$/;"	m	class:m_graph::AutoUniGraph	access:private
m_graph::AutoUniGraph::add_node	graph.h	/^        inline NodeId add_node(const Node& node) {$/;"	f	class:m_graph::AutoUniGraph	access:public	signature:(const Node& node)
m_graph::AutoUniGraph::clear_	graph.h	/^        virtual void clear_(){$/;"	f	class:m_graph::AutoUniGraph	access:public	signature:()
m_graph::AutoUniGraph::contain_node	graph.h	/^        inline bool contain_node(const Node& node){$/;"	f	class:m_graph::AutoUniGraph	access:public	signature:(const Node& node)
m_graph::AutoUniGraph::get_node	graph.h	/^        inline const Node& get_node(const NodeId& id) const$/;"	f	class:m_graph::AutoUniGraph	access:public	signature:(const NodeId& id) const
m_graph::AutoUniGraph::get_node	graph.h	/^        inline const Node& get_node(const NodeId& id)$/;"	f	class:m_graph::AutoUniGraph	access:public	signature:(const NodeId& id)
m_graph::AutoUniGraph::modify_node	graph.h	/^        inline void modify_node(const NodeId& id, const Node& node){$/;"	f	class:m_graph::AutoUniGraph	access:public	signature:(const NodeId& id, const Node& node)
m_graph::AutoUniGraph::remove_node	graph.h	/^        inline void remove_node(const NodeId& id)$/;"	f	class:m_graph::AutoUniGraph	access:public	signature:(const NodeId& id)
m_graph::AutoUniGraph::~AutoUniGraph	graph.h	/^        virtual ~AutoUniGraph (){$/;"	f	class:m_graph::AutoUniGraph	access:public	signature:()
m_graph::BaseGraph	graph.h	/^class BaseGraph$/;"	c	namespace:m_graph
m_graph::BaseGraph::AdjIter	graph.h	/^        typedef typename graph_traits<GraphContainer>::adjacency_iterator AdjIter;$/;"	t	class:m_graph::BaseGraph	access:public
m_graph::BaseGraph::AdjRange	graph.h	/^        typedef std::pair<AdjIter, AdjIter> AdjRange;$/;"	t	class:m_graph::BaseGraph	access:public
m_graph::BaseGraph::BaseGraph	graph.h	/^        BaseGraph() {$/;"	f	class:m_graph::BaseGraph	access:public	signature:()
m_graph::BaseGraph::BaseGraph	graph.h	/^        BaseGraph(const BaseGraph& g) : _g(g._g) {$/;"	f	class:m_graph::BaseGraph	access:public	signature:(const BaseGraph& g)
m_graph::BaseGraph::BaseGraph	graph.h	/^        BaseGraph(int numNode) :_g(numNode){$/;"	f	class:m_graph::BaseGraph	access:public	signature:(int numNode)
m_graph::BaseGraph::ConstEdgeWeightsMap	graph.h	/^        typedef typename property_map<GraphContainer, boost::edge_weight_t>::const_type ConstEdgeWeightsMap;$/;"	t	class:m_graph::BaseGraph	access:public
m_graph::BaseGraph::DegreeSize	graph.h	/^        typedef typename graph_traits<GraphContainer>::degree_size_type DegreeSize;$/;"	t	class:m_graph::BaseGraph	access:public
m_graph::BaseGraph::EdgeId	graph.h	/^        typedef typename graph_traits<GraphContainer>::edge_descriptor EdgeId;$/;"	t	class:m_graph::BaseGraph	access:public
m_graph::BaseGraph::EdgeIter	graph.h	/^        typedef typename graph_traits<GraphContainer>::edge_iterator EdgeIter;$/;"	t	class:m_graph::BaseGraph	access:public
m_graph::BaseGraph::EdgePair	graph.h	/^        typedef std::pair<NodeId, NodeId> EdgePair;$/;"	t	class:m_graph::BaseGraph	access:public
m_graph::BaseGraph::EdgeRange	graph.h	/^        typedef std::pair<EdgeIter, EdgeIter> EdgeRange;$/;"	t	class:m_graph::BaseGraph	access:public
m_graph::BaseGraph::EdgeWeightsMap	graph.h	/^        typedef typename property_map<GraphContainer, boost::edge_weight_t>::type EdgeWeightsMap;$/;"	t	class:m_graph::BaseGraph	access:public
m_graph::BaseGraph::InEdgeIter	graph.h	/^        typedef typename graph_traits<GraphContainer>::in_edge_iterator InEdgeIter;$/;"	t	class:m_graph::BaseGraph	access:public
m_graph::BaseGraph::InEdgeRange	graph.h	/^        typedef std::pair<InEdgeIter, InEdgeIter> InEdgeRange;$/;"	t	class:m_graph::BaseGraph	access:public
m_graph::BaseGraph::NodeId	graph.h	/^        typedef typename graph_traits<GraphContainer>::vertex_descriptor NodeId;$/;"	t	class:m_graph::BaseGraph	access:public
m_graph::BaseGraph::NodeIter	graph.h	/^        typedef typename graph_traits<GraphContainer>::vertex_iterator NodeIter;$/;"	t	class:m_graph::BaseGraph	access:public
m_graph::BaseGraph::NodeRange	graph.h	/^        typedef std::pair<NodeIter, NodeIter> NodeRange;$/;"	t	class:m_graph::BaseGraph	access:public
m_graph::BaseGraph::OutEdgeIter	graph.h	/^        typedef typename graph_traits<GraphContainer>::out_edge_iterator OutEdgeIter;$/;"	t	class:m_graph::BaseGraph	access:public
m_graph::BaseGraph::OutEdgeRange	graph.h	/^        typedef std::pair<OutEdgeIter, OutEdgeIter> OutEdgeRange;$/;"	t	class:m_graph::BaseGraph	access:public
m_graph::BaseGraph::SizeType	graph.h	/^        typedef typename graph_traits<GraphContainer>::vertices_size_type SizeType;$/;"	t	class:m_graph::BaseGraph	access:public
m_graph::BaseGraph::_g	graph.h	/^        GraphContainer _g;$/;"	m	class:m_graph::BaseGraph	access:protected
m_graph::BaseGraph::add_edge	graph.h	/^            add_edge(const NodeId& source, const NodeId& target)$/;"	f	class:m_graph::BaseGraph	access:public	signature:(const NodeId& source, const NodeId& target)
m_graph::BaseGraph::add_node	graph.h	/^        inline NodeId add_node() {$/;"	f	class:m_graph::BaseGraph	access:public	signature:()
m_graph::BaseGraph::clear	graph.h	/^        inline void clear()$/;"	f	class:m_graph::BaseGraph	access:public	signature:()
m_graph::BaseGraph::clear_	graph.h	/^        virtual void clear_(){ }$/;"	f	class:m_graph::BaseGraph	access:public	signature:()
m_graph::BaseGraph::edge_weights	graph.h	/^        inline EdgeWeightsMap edge_weights() {$/;"	f	class:m_graph::BaseGraph	access:public	signature:()
m_graph::BaseGraph::edge_weights	graph.h	/^        inline const EdgeWeightsMap edge_weights() const{$/;"	f	class:m_graph::BaseGraph	access:public	signature:() const
m_graph::BaseGraph::get_adj_nodes	graph.h	/^        inline AdjRange get_adj_nodes(const NodeId& id) const$/;"	f	class:m_graph::BaseGraph	access:public	signature:(const NodeId& id) const
m_graph::BaseGraph::get_all_edges	graph.h	/^        inline EdgeRange get_all_edges() const{$/;"	f	class:m_graph::BaseGraph	access:public	signature:() const
m_graph::BaseGraph::get_all_nodes	graph.h	/^        inline NodeRange get_all_nodes() const$/;"	f	class:m_graph::BaseGraph	access:public	signature:() const
m_graph::BaseGraph::get_container	graph.h	/^        inline GraphContainer& get_container() $/;"	f	class:m_graph::BaseGraph	access:public	signature:()
m_graph::BaseGraph::get_container	graph.h	/^        inline const GraphContainer& get_container() const$/;"	f	class:m_graph::BaseGraph	access:public	signature:() const
m_graph::BaseGraph::get_degree	graph.h	/^        inline int get_degree(const NodeId& id) const$/;"	f	class:m_graph::BaseGraph	access:public	signature:(const NodeId& id) const
m_graph::BaseGraph::get_edge	graph.h	/^        inline EdgePair get_edge(const EdgeId& id) const {$/;"	f	class:m_graph::BaseGraph	access:public	signature:(const EdgeId& id) const
m_graph::BaseGraph::get_in_degree	graph.h	/^        inline int get_in_degree(const NodeId& id) const$/;"	f	class:m_graph::BaseGraph	access:public	signature:(const NodeId& id) const
m_graph::BaseGraph::get_in_edges	graph.h	/^        inline InEdgeRange get_in_edges(const NodeId& id) const{$/;"	f	class:m_graph::BaseGraph	access:public	signature:(const NodeId& id) const
m_graph::BaseGraph::get_out_degree	graph.h	/^        inline int get_out_degree(const NodeId& id) const$/;"	f	class:m_graph::BaseGraph	access:public	signature:(const NodeId& id) const
m_graph::BaseGraph::get_out_edges	graph.h	/^        inline OutEdgeRange get_out_edges(const NodeId& id) const{$/;"	f	class:m_graph::BaseGraph	access:public	signature:(const NodeId& id) const
m_graph::BaseGraph::num_edges	graph.h	/^        inline int num_edges( ) const{$/;"	f	class:m_graph::BaseGraph	access:public	signature:( ) const
m_graph::BaseGraph::num_nodes	graph.h	/^        inline int num_nodes() const$/;"	f	class:m_graph::BaseGraph	access:public	signature:() const
m_graph::BaseGraph::operator =	graph.h	/^        BaseGraph& operator = (const BaseGraph &rhs)$/;"	f	class:m_graph::BaseGraph	access:public	signature:(const BaseGraph &rhs)
m_graph::BaseGraph::remove_node	graph.h	/^        inline void remove_node(const NodeId& id)$/;"	f	class:m_graph::BaseGraph	access:public	signature:(const NodeId& id)
m_graph::BaseGraph::set_container	graph.h	/^        void set_container(GraphContainer *g){$/;"	f	class:m_graph::BaseGraph	access:public	signature:(GraphContainer *g)
m_graph::BaseGraph::sourceId	graph.h	/^        inline NodeId sourceId(const EdgeId& id) const{$/;"	f	class:m_graph::BaseGraph	access:public	signature:(const EdgeId& id) const
m_graph::BaseGraph::sourceId	graph.h	/^        inline NodeId sourceId(const EdgeId& id){$/;"	f	class:m_graph::BaseGraph	access:public	signature:(const EdgeId& id)
m_graph::BaseGraph::targetId	graph.h	/^        inline NodeId targetId(const EdgeId& id) const{$/;"	f	class:m_graph::BaseGraph	access:public	signature:(const EdgeId& id) const
m_graph::BaseGraph::targetId	graph.h	/^        inline NodeId targetId(const EdgeId& id){$/;"	f	class:m_graph::BaseGraph	access:public	signature:(const EdgeId& id)
m_graph::BaseGraph::~BaseGraph	graph.h	/^        virtual ~BaseGraph() {$/;"	f	class:m_graph::BaseGraph	access:public	signature:()
m_graph::GraphUtil	graph.h	/^class GraphUtil {$/;"	c	namespace:m_graph
m_graph::GraphUtil::GraphUtil	graph.h	/^    GraphUtil (Graph *graph):_g(graph){$/;"	f	class:m_graph::GraphUtil	access:public	signature:(Graph *graph)
m_graph::GraphUtil::_dMatrix	graph.h	/^    MatrixGraph _dMatrix;                        \/\/!< distance matrix $/;"	m	class:m_graph::GraphUtil	access:public
m_graph::GraphUtil::_g	graph.h	/^    Graph *_g;                              \/\/!< the graph $/;"	m	class:m_graph::GraphUtil	access:private
m_graph::GraphUtil::create_matrix	graph.h	/^    inline void create_matrix(){$/;"	f	class:m_graph::GraphUtil	access:public	signature:()
m_graph::GraphUtil::johnson_all_pairs_shortest_paths	graph.h	/^    void johnson_all_pairs_shortest_paths(){$/;"	f	class:m_graph::GraphUtil	access:public	signature:()
m_graph::GraphUtil::print_matrix	graph.h	/^    void print_matrix(){$/;"	f	class:m_graph::GraphUtil	access:public	signature:()
m_graph::GraphUtil::random_graph	graph.h	/^    void random_graph(int num_vertex, int num_edge){$/;"	f	class:m_graph::GraphUtil	access:public	signature:(int num_vertex, int num_edge)
m_graph::GraphUtil::to_matrix_graph	graph.h	/^    void to_matrix_graph( ){$/;"	f	class:m_graph::GraphUtil	access:public	signature:( )
m_graph::GraphUtil::write2dot	graph.h	/^    void write2dot(std::string filename){$/;"	f	class:m_graph::GraphUtil	access:public	signature:(std::string filename)
m_graph::GraphUtil::~GraphUtil	graph.h	/^    virtual ~GraphUtil (){ };$/;"	f	class:m_graph::GraphUtil	access:public	signature:()
m_graph::ManualUniGraph	graph.h	/^class ManualUniGraph :public BaseGraph<GraphContainer>{$/;"	c	namespace:m_graph	inherits:BaseGraph
m_graph::ManualUniGraph::AdjIter	graph.h	/^        typedef typename BaseGraph<GraphContainer>::AdjIter AdjIter;$/;"	t	class:m_graph::ManualUniGraph	access:public
m_graph::ManualUniGraph::AdjRange	graph.h	/^        typedef std::pair<AdjIter, AdjIter> AdjRange;$/;"	t	class:m_graph::ManualUniGraph	access:public
m_graph::ManualUniGraph::DegreeSize	graph.h	/^        typedef typename BaseGraph<GraphContainer>::DegreeSize DegreeSize;$/;"	t	class:m_graph::ManualUniGraph	access:public
m_graph::ManualUniGraph::EdgeId	graph.h	/^        typedef typename BaseGraph<GraphContainer>::EdgeId EdgeId;$/;"	t	class:m_graph::ManualUniGraph	access:public
m_graph::ManualUniGraph::EdgeIter	graph.h	/^        typedef typename BaseGraph<GraphContainer>::EdgeIter EdgeIter;$/;"	t	class:m_graph::ManualUniGraph	access:public
m_graph::ManualUniGraph::EdgePair	graph.h	/^        typedef std::pair<NodeId, NodeId> EdgePair;$/;"	t	class:m_graph::ManualUniGraph	access:public
m_graph::ManualUniGraph::EdgeRange	graph.h	/^        typedef std::pair<EdgeIter, EdgeIter> EdgeRange;$/;"	t	class:m_graph::ManualUniGraph	access:public
m_graph::ManualUniGraph::EdgeWeightsMap	graph.h	/^        typedef typename BaseGraph<GraphContainer>::EdgeWeightsMap EdgeWeightsMap;$/;"	t	class:m_graph::ManualUniGraph	access:public
m_graph::ManualUniGraph::InEdgeIter	graph.h	/^        typedef typename BaseGraph<GraphContainer>::InEdgeIter InEdgeIter;$/;"	t	class:m_graph::ManualUniGraph	access:public
m_graph::ManualUniGraph::InEdgeRange	graph.h	/^        typedef std::pair<InEdgeIter, InEdgeIter> InEdgeRange;$/;"	t	class:m_graph::ManualUniGraph	access:public
m_graph::ManualUniGraph::ManualUniGraph	graph.h	/^        ManualUniGraph (){ $/;"	f	class:m_graph::ManualUniGraph	access:public	signature:()
m_graph::ManualUniGraph::ManualUniGraph	graph.h	/^        ManualUniGraph (int numNode):BaseGraph<GraphContainer>(numNode){ $/;"	f	class:m_graph::ManualUniGraph	access:public	signature:(int numNode)
m_graph::ManualUniGraph::NodeId	graph.h	/^        typedef typename BaseGraph<GraphContainer>::NodeId NodeId;$/;"	t	class:m_graph::ManualUniGraph	access:public
m_graph::ManualUniGraph::NodeIter	graph.h	/^        typedef typename BaseGraph<GraphContainer>::NodeIter NodeIter;$/;"	t	class:m_graph::ManualUniGraph	access:public
m_graph::ManualUniGraph::NodeRange	graph.h	/^        typedef std::pair<NodeIter, NodeIter> NodeRange;$/;"	t	class:m_graph::ManualUniGraph	access:public
m_graph::ManualUniGraph::NodeType	graph.h	/^        typedef Node NodeType;$/;"	t	class:m_graph::ManualUniGraph	access:public
m_graph::ManualUniGraph::NodesMap	graph.h	/^        typedef typename property_map<GraphContainer, vertex_node_t>::type NodesMap;$/;"	t	class:m_graph::ManualUniGraph	access:public
m_graph::ManualUniGraph::OutEdgeIter	graph.h	/^        typedef typename BaseGraph<GraphContainer>::OutEdgeIter OutEdgeIter;$/;"	t	class:m_graph::ManualUniGraph	access:public
m_graph::ManualUniGraph::OutEdgeRange	graph.h	/^        typedef std::pair<OutEdgeIter, OutEdgeIter> OutEdgeRange;$/;"	t	class:m_graph::ManualUniGraph	access:public
m_graph::ManualUniGraph::SizeType	graph.h	/^        typedef typename BaseGraph<GraphContainer>::SizeType SizeType;$/;"	t	class:m_graph::ManualUniGraph	access:public
m_graph::ManualUniGraph::add_node	graph.h	/^        inline NodeId add_node(const Node& node) {$/;"	f	class:m_graph::ManualUniGraph	access:public	signature:(const Node& node)
m_graph::ManualUniGraph::get_node	graph.h	/^        inline const Node& get_node(const NodeId& id)const$/;"	f	class:m_graph::ManualUniGraph	access:public	signature:(const NodeId& id) const
m_graph::ManualUniGraph::modify_node	graph.h	/^        inline void modify_node(const NodeId& id, const Node& node){$/;"	f	class:m_graph::ManualUniGraph	access:public	signature:(const NodeId& id, const Node& node)
m_graph::ManualUniGraph::nodes	graph.h	/^        NodesMap nodes;$/;"	m	class:m_graph::ManualUniGraph	access:private
m_graph::ManualUniGraph::remove_node	graph.h	/^        inline void remove_node(const NodeId& id)$/;"	f	class:m_graph::ManualUniGraph	access:public	signature:(const NodeId& id)
m_graph::ManualUniGraph::~ManualUniGraph	graph.h	/^        virtual ~ManualUniGraph (){ };$/;"	f	class:m_graph::ManualUniGraph	access:public	signature:()
m_graph::MatrixGraph	graph.h	/^    typedef std::vector< std::vector<int> > MatrixGraph;$/;"	t	namespace:m_graph
m_graph::MatrixGraph	graph.h	/^typedef std::vector<std::vector<int> > MatrixGraph;$/;"	t	namespace:m_graph
m_graph::print_graph	graph.h	/^    void print_graph(MatrixGraph &graph);$/;"	p	namespace:m_graph	signature:(MatrixGraph &graph)
m_graph::read_graph	graph.h	/^    void read_graph(std::string filename, MatrixGraph &graph);$/;"	p	namespace:m_graph	signature:(std::string filename, MatrixGraph &graph)
main	main.cpp	/^int main(int argc, char** argv)$/;"	f	signature:(int argc, char** argv)
merge	cluster_node.cpp	/^void ClusterNode::merge(const void *n1, const void *n2)$/;"	f	class:ClusterNode	signature:(const void *n1, const void *n2)
merge	cluster_node.h	/^        static void merge(const void *n1, const void *n2);$/;"	p	class:ClusterNode	access:public	signature:(const void *n1, const void *n2)
merge	component.h	/^         inline static int merge(double component_diff,   Component &s, Component &t){$/;"	f	class:Component	access:public	signature:(double component_diff, Component &s, Component &t)
merge_from	component.h	/^        inline void merge_from(const Component &r){$/;"	f	class:Component	access:public	signature:(const Component &r)
model_info	segment2d.h	/^        void model_info( );$/;"	p	class:Segment2D	access:public	signature:( )
model_info	segment2d.h	/^void Segment2D<T>::model_info(){$/;"	f	class:Segment2D	signature:()
modify_node	graph.h	/^        inline void modify_node(const NodeId& id, const Node& node){$/;"	f	class:m_graph::AutoUniGraph	access:public	signature:(const NodeId& id, const Node& node)
modify_node	graph.h	/^        inline void modify_node(const NodeId& id, const Node& node){$/;"	f	class:m_graph::ManualUniGraph	access:public	signature:(const NodeId& id, const Node& node)
mouseEventOccurred	util.cpp	/^void mouseEventOccurred (const pcl::visualization::MouseEvent &event,$/;"	f	signature:(const pcl::visualization::MouseEvent &event, void* viewer_void)
mouseEventOccurred	util.h	/^void mouseEventOccurred (const pcl::visualization::MouseEvent &event,$/;"	p	signature:(const pcl::visualization::MouseEvent &event, void* viewer_void)
move2offset	vizblockworld.h	/^            void move2offset(T cloud, float unit = 1){$/;"	f	class:VizBlockWorld	access:public	signature:(T cloud, float unit = 1)
myCorrespondence_	icp.h	/^      BiMap myCorrespondence_;$/;"	m	class:IterativeClosestPoint	access:protected
my_fittingCylinderCost	cluster_node.h	/^        static double my_fittingCylinderCost(const void *, const void *);$/;"	p	class:ClusterNode	access:public	signature:(const void *, const void *)
my_fittingPlaneCost	cluster_node.h	/^        static double my_fittingPlaneCost(const void *, const void *);$/;"	p	class:ClusterNode	access:public	signature:(const void *, const void *)
my_fittingSphereCost	cluster_node.h	/^        static double my_fittingSphereCost(const void *, const void *);$/;"	p	class:ClusterNode	access:public	signature:(const void *, const void *)
n	emd.h	/^  int n;                \/* Number of features in the signature *\/$/;"	m	struct:__anon1	access:public
nearest_k_search2	util.h	/^void nearest_k_search2(std::vector<T> &points, const T& searchPoint, int nn = 10, int dim = 3){$/;"	f	signature:(std::vector<T> &points, const T& searchPoint, int nn = 10, int dim = 3)
newSol	emd.cpp	/^static void newSol()$/;"	f	file:	signature:()
newSol	emd.cpp	/^static void newSol();$/;"	p	file:	signature:()
node1_t	emd.cpp	/^typedef struct node1_t {$/;"	s	file:
node1_t	emd.cpp	/^} node1_t;$/;"	t	typeref:struct:node1_t	file:
node1_t::Next	emd.cpp	/^    struct node1_t *Next;$/;"	m	struct:node1_t	typeref:struct:node1_t::node1_t	file:	access:public
node1_t::i	emd.cpp	/^    int i;$/;"	m	struct:node1_t	file:	access:public
node1_t::val	emd.cpp	/^    double val;$/;"	m	struct:node1_t	file:	access:public
node2_t	emd.cpp	/^typedef struct node2_t {$/;"	s	file:
node2_t	emd.cpp	/^} node2_t;$/;"	t	typeref:struct:node2_t	file:
node2_t::NextC	emd.cpp	/^    struct node2_t *NextC;               \/* NEXT COLUMN *\/$/;"	m	struct:node2_t	typeref:struct:node2_t::node2_t	file:	access:public
node2_t::NextR	emd.cpp	/^    struct node2_t *NextR;               \/* NEXT ROW *\/$/;"	m	struct:node2_t	typeref:struct:node2_t::node2_t	file:	access:public
node2_t::i	emd.cpp	/^    int i, j;$/;"	m	struct:node2_t	file:	access:public
node2_t::j	emd.cpp	/^    int i, j;$/;"	m	struct:node2_t	file:	access:public
node2_t::val	emd.cpp	/^    double val;$/;"	m	struct:node2_t	file:	access:public
nodes	graph.h	/^        NodesMap nodes;$/;"	m	class:m_graph::ManualUniGraph	access:private
numLeafs	cluster_node.cpp	/^int TrNode::numLeafs = 0;$/;"	m	class:TrNode	file:
numLeafs	cluster_node.h	/^    static int numLeafs;$/;"	m	struct:TrNode	access:public
num_edges	graph.h	/^        inline int num_edges( ) const{$/;"	f	class:m_graph::BaseGraph	access:public	signature:( ) const
num_nodes	graph.h	/^        inline int num_nodes() const$/;"	f	class:m_graph::BaseGraph	access:public	signature:() const
num_triangles	cluster_node.cpp	/^int ClusterNode::num_triangles = 0;$/;"	m	class:ClusterNode	file:
num_triangles	cluster_node.h	/^        static int num_triangles;$/;"	m	class:ClusterNode	access:public
objects	main.cpp	/^CloudVector objects;$/;"	v
operator ()	segment2d.h	/^            bool  operator()(const Component2D& arg1) const{$/;"	f	struct:Segment2D::Filter	access:public	signature:(const Component2D& arg1) const
operator <	cluster_node.h	/^    bool operator<(const TrNode& r) const{$/;"	f	struct:TrNode	access:public	signature:(const TrNode& r) const
operator <	component.h	/^        bool operator < (const WeightEdge &r) const{$/;"	f	class:WeightEdge	access:public	signature:(const WeightEdge &r) const
operator <	component.h	/^        inline bool operator < (const Component &r) const{$/;"	f	class:Component	access:public	signature:(const Component &r) const
operator <	emd.h	/^  bool operator < (const flow_t &other) const{$/;"	f	struct:flow_t	access:public	signature:(const flow_t &other) const
operator <	pixel.h	/^        bool operator < (const GrayPixel2D &other) const{$/;"	f	class:GrayPixel2D	access:public	signature:(const GrayPixel2D &other) const
operator <	pixel.h	/^        bool operator < (const GrayPixel3D &other) const{$/;"	f	class:GrayPixel3D	access:public	signature:(const GrayPixel3D &other) const
operator <	pixel.h	/^        bool operator < (const RgbPixel2D &other) const{$/;"	f	class:RgbPixel2D	access:public	signature:(const RgbPixel2D &other) const
operator <	pixel.h	/^        bool operator < (const RgbPixel3D &other) const{$/;"	f	class:RgbPixel3D	access:public	signature:(const RgbPixel3D &other) const
operator <<	pixel.cpp	/^std::ostream& operator << (std::ostream& out, const GrayPixel2D& t){$/;"	f	signature:(std::ostream& out, const GrayPixel2D& t)
operator <<	pixel.cpp	/^std::ostream& operator << (std::ostream& out, const GrayPixel2D* t){$/;"	f	signature:(std::ostream& out, const GrayPixel2D* t)
operator <<	pixel.cpp	/^std::ostream& operator << (std::ostream& out, const GrayPixel3D& t){$/;"	f	signature:(std::ostream& out, const GrayPixel3D& t)
operator <<	pixel.cpp	/^std::ostream& operator << (std::ostream& out, const GrayPixel3D* t){$/;"	f	signature:(std::ostream& out, const GrayPixel3D* t)
operator <<	pixel.cpp	/^std::ostream& operator << (std::ostream& out, const RgbPixel2D& t){$/;"	f	signature:(std::ostream& out, const RgbPixel2D& t)
operator <<	pixel.cpp	/^std::ostream& operator << (std::ostream& out, const RgbPixel2D* t){$/;"	f	signature:(std::ostream& out, const RgbPixel2D* t)
operator <<	pixel.cpp	/^std::ostream& operator << (std::ostream& out, const RgbPixel3D& t){$/;"	f	signature:(std::ostream& out, const RgbPixel3D& t)
operator <<	pixel.cpp	/^std::ostream& operator << (std::ostream& out, const RgbPixel3D* t){$/;"	f	signature:(std::ostream& out, const RgbPixel3D* t)
operator <<	pixel.h	/^std::ostream& operator << (std::ostream& out, const GrayPixel2D& t);$/;"	p	signature:(std::ostream& out, const GrayPixel2D& t)
operator <<	pixel.h	/^std::ostream& operator << (std::ostream& out, const GrayPixel2D* t);$/;"	p	signature:(std::ostream& out, const GrayPixel2D* t)
operator <<	pixel.h	/^std::ostream& operator << (std::ostream& out, const GrayPixel3D& t);$/;"	p	signature:(std::ostream& out, const GrayPixel3D& t)
operator <<	pixel.h	/^std::ostream& operator << (std::ostream& out, const GrayPixel3D* t);$/;"	p	signature:(std::ostream& out, const GrayPixel3D* t)
operator <<	pixel.h	/^std::ostream& operator << (std::ostream& out, const RgbPixel2D& t);$/;"	p	signature:(std::ostream& out, const RgbPixel2D& t)
operator <<	pixel.h	/^std::ostream& operator << (std::ostream& out, const RgbPixel2D* t);$/;"	p	signature:(std::ostream& out, const RgbPixel2D* t)
operator <<	pixel.h	/^std::ostream& operator << (std::ostream& out, const RgbPixel3D& t);$/;"	p	signature:(std::ostream& out, const RgbPixel3D& t)
operator <<	pixel.h	/^std::ostream& operator << (std::ostream& out, const RgbPixel3D* t);$/;"	p	signature:(std::ostream& out, const RgbPixel3D* t)
operator =	graph.h	/^        BaseGraph& operator = (const BaseGraph &rhs)$/;"	f	class:m_graph::BaseGraph	access:public	signature:(const BaseGraph &rhs)
operator ==	cluster_node.cpp	/^bool operator == (const TrNode& a, const TrNode &b) {$/;"	f	signature:(const TrNode& a, const TrNode &b)
operator ==	cluster_node.h	/^bool operator == (const TrNode& a, const TrNode &b);$/;"	p	signature:(const TrNode& a, const TrNode &b)
operator []	pixelworld2d.h	/^        T* operator[](int rowIndx) { return _pixels[rowIndx]; }$/;"	f	class:PixelWorld2D	access:public	signature:(int rowIndx)
operator []	pixelworld2d.h	/^        const T* operator[](int rowIndx)const { return _pixels[rowIndx]; }$/;"	f	class:PixelWorld2D	access:public	signature:(int rowIndx) const
operator []	pixelworld3d.h	/^        T* operator[](int rowIndx) { return _pixels[rowIndx]; }$/;"	f	class:PixelWorld3D	access:public	signature:(int rowIndx)
operator []	pixelworld3d.h	/^        const T* operator[](int rowIndx)const { return _pixels[rowIndx]; }$/;"	f	class:PixelWorld3D	access:public	signature:(int rowIndx) const
output_	icp.h	/^      PointCloudSource *output_;$/;"	m	class:IterativeClosestPoint	access:protected
parentId	cluster_node.h	/^        NodeId parentId(NodeId id){$/;"	f	class:BinaryTree	access:public	signature:(NodeId id)
parentId	cluster_node.h	/^    int parentId;$/;"	m	struct:TrNode	access:public
pcdFiles	main.cpp	/^vector<string> pcdFiles;$/;"	v
pcd_in_path	main.cpp	/^void pcd_in_path(const std::string &fname){$/;"	f	signature:(const std::string &fname)
percent	cluster_node.h	/^    double percent;$/;"	m	struct:TrNode	access:public
planes	main.cpp	/^CloudVector planes;$/;"	v
point	cluster_node.h	/^    Point point;$/;"	m	struct:Coefficient	access:public
pos_MDS	triangulate.cpp	/^MyTriangulation::pos_MDS(PointCloudPtr posNodes, const MatrixGraph &dstMatrix){$/;"	f	class:MyTriangulation	signature:(PointCloudPtr posNodes, const MatrixGraph &dstMatrix)
pos_MDS	triangulate.h	/^        void pos_MDS(PointCloudPtr posNodes, const MatrixGraph &dstMatrix);$/;"	p	class:MyTriangulation	access:protected	signature:(PointCloudPtr posNodes, const MatrixGraph &dstMatrix)
pos_and_weight	triangulate.cpp	/^void MyTriangulation::pos_and_weight(const std::string &fname,$/;"	f	class:MyTriangulation	signature:(const std::string &fname, PointCloudPtr posNodes, vector<float> *wNodes)
pos_and_weight	triangulate.h	/^        void pos_and_weight(const std::string &fname,$/;"	p	class:MyTriangulation	access:public	signature:(const std::string &fname, PointCloudPtr posNodes, vector<float> *wNodes)
prepare4segmentation	triangulate.h	/^        inline void prepare4segmentation()const{$/;"	f	class:MyTriangulation	access:protected	signature:() const
previousEMD_	icp.h	/^      float previousEMD_;$/;"	m	class:IterativeClosestPoint	access:protected
printSolution	emd.cpp	/^static void printSolution()$/;"	f	file:	signature:()
printSolution	emd.cpp	/^static void printSolution();$/;"	p	file:	signature:()
print_graph	graph.cpp	/^    void print_graph(MatrixGraph &graph){$/;"	f	signature:(MatrixGraph &graph)
print_graph	graph.h	/^    void print_graph(MatrixGraph &graph);$/;"	p	namespace:m_graph	signature:(MatrixGraph &graph)
print_matrix	graph.h	/^    void print_matrix(){$/;"	f	class:m_graph::GraphUtil	access:public	signature:()
push_def_cloud	vizblockworld.h	/^        std::string push_def_cloud(int viewport = 0, int pointSize = 1){$/;"	f	class:VizBlockWorld	access:public	signature:(int viewport = 0, int pointSize = 1)
radius	cluster_node.h	/^    double radius;$/;"	m	struct:Coefficient	access:public
random_graph	graph.h	/^    void random_graph(int num_vertex, int num_edge){$/;"	f	class:m_graph::GraphUtil	access:public	signature:(int num_vertex, int num_edge)
read_graph	graph.cpp	/^    void read_graph(std::string filename, MatrixGraph &graph){$/;"	f	signature:(std::string filename, MatrixGraph &graph)
read_graph	graph.h	/^    void read_graph(std::string filename, MatrixGraph &graph);$/;"	p	namespace:m_graph	signature:(std::string filename, MatrixGraph &graph)
register_keyboard_event	vizblockworld.h	/^        void register_keyboard_event(void (*callback) (const pcl::visualization::KeyboardEvent &event,$/;"	f	class:VizBlockWorld	access:public	signature:(void (*callback) (const pcl::visualization::KeyboardEvent &event, void *viewer_void))
register_mouse_event	vizblockworld.h	/^        void register_mouse_event(void (*callback) (const pcl::visualization::MouseEvent &event,$/;"	f	class:VizBlockWorld	access:public	signature:(void (*callback) (const pcl::visualization::MouseEvent &event, void *viewer_void))
remove_cloud	vizblockworld.h	/^        void remove_cloud(const std::string &id){$/;"	f	class:VizBlockWorld	access:public	signature:(const std::string &id)
remove_node	graph.h	/^        inline void remove_node(const NodeId& id)$/;"	f	class:m_graph::AutoUniGraph	access:public	signature:(const NodeId& id)
remove_node	graph.h	/^        inline void remove_node(const NodeId& id)$/;"	f	class:m_graph::BaseGraph	access:public	signature:(const NodeId& id)
remove_node	graph.h	/^        inline void remove_node(const NodeId& id)$/;"	f	class:m_graph::ManualUniGraph	access:public	signature:(const NodeId& id)
remove_shape	vizblockworld.h	/^        void remove_shape(const std::string &id){$/;"	f	class:VizBlockWorld	access:public	signature:(const std::string &id)
reset	cluster_node.cpp	/^void ClusterNode::reset(){$/;"	f	class:ClusterNode	signature:()
reset	cluster_node.h	/^        static void reset();$/;"	p	class:ClusterNode	access:public	signature:()
reset_camera	vizblockworld.h	/^        void reset_camera(){$/;"	f	class:VizBlockWorld	access:public	signature:()
right_one	component.h	/^        inline Component* right_one(){$/;"	f	class:Component	access:public	signature:()
rootId	cluster_node.cpp	/^BinaryTree::NodeId ClusterNode::rootId;$/;"	m	class:ClusterNode	file:
rootId	cluster_node.h	/^        static BinaryTree::NodeId rootId;$/;"	m	class:ClusterNode	access:public
russel	emd.cpp	/^static void russel(double *S, double *D)$/;"	f	file:	signature:(double *S, double *D)
russel	emd.cpp	/^static void russel(double *S, double *D);$/;"	p	file:	signature:(double *S, double *D)
save	segment2d.h	/^        void save(std::string filename, int optScale = 0, int filterSize = 0);$/;"	p	class:Segment2D	access:public	signature:(std::string filename, int optScale = 0, int filterSize = 0)
save	segment2d.h	/^void Segment2D<T>::save(std::string filename, int optScale, int filterSize){$/;"	f	class:Segment2D	signature:(std::string filename, int optScale, int filterSize)
save	segment3d.h	/^        void save(std::string filename, int optScale = 0, int filterSize = 0);$/;"	p	class:Segment3D	access:public	signature:(std::string filename, int optScale = 0, int filterSize = 0)
save	segment3d.h	/^void Segment3D<T>::save(std::string filename, int optScale, int filterSize){$/;"	f	class:Segment3D	signature:(std::string filename, int optScale, int filterSize)
save	vizblockworld.h	/^        void save(std::string filename){$/;"	f	class:VizBlockWorld	access:public	signature:(std::string filename)
scene_cluster	main.cpp	/^void scene_cluster(const std::string &fname){$/;"	f	signature:(const std::string &fname)
segment	segment2d.h	/^        void segment(int arg = 70);$/;"	p	class:Segment2D	access:public	signature:(int arg = 70)
segment	segment2d.h	/^void Segment2D<T>::segment(int arg){$/;"	f	class:Segment2D	signature:(int arg)
segment	segment3d.h	/^        void segment(int arg = 0);$/;"	p	class:Segment3D	access:public	signature:(int arg = 0)
segment	segment3d.h	/^void Segment3D<T>::segment(int arg ){$/;"	f	class:Segment3D	signature:(int arg )
segment_mesh	main.cpp	/^void segment_mesh(PointCloudPtr points){$/;"	f	signature:(PointCloudPtr points)
segment_plane	vizblockworld.cpp	/^void segment_plane (const pcl::PointCloud<PointT>::Ptr cloud,$/;"	f	signature:(const pcl::PointCloud<PointT>::Ptr cloud, pcl::PointCloud<PointT>::Ptr objects, CloudVector* planes)
segment_plane	vizblockworld.h	/^void segment_plane (const pcl::PointCloud<PointT>::Ptr cloud, pcl::PointCloud<PointT>::Ptr objects, CloudVector* planes);$/;"	p	signature:(const pcl::PointCloud<PointT>::Ptr cloud, pcl::PointCloud<PointT>::Ptr objects, CloudVector* planes)
segment_points	triangulate.cpp	/^void MyTriangulation::segment_points(const pcl::PointCloud<pcl::PointXYZ>::Ptr points){$/;"	f	class:MyTriangulation	signature:(const pcl::PointCloud<pcl::PointXYZ>::Ptr points)
segment_points	triangulate.h	/^        void segment_points(const pcl::PointCloud<pcl::PointXYZ>::Ptr points);$/;"	p	class:MyTriangulation	access:public	signature:(const pcl::PointCloud<pcl::PointXYZ>::Ptr points)
setInputWeight	icp.h	/^      void setInputWeight(const std::vector<float> &wInput);$/;"	p	class:IterativeClosestPoint	access:public	signature:(const std::vector<float> &wInput)
setOutputWeight	icp.h	/^      void setOutputWeight(const std::vector<float> &wOutput);$/;"	p	class:IterativeClosestPoint	access:public	signature:(const std::vector<float> &wOutput)
set_backgroundcolor	vizblockworld.h	/^        void set_backgroundcolor(int r, int g, int b, int viewport = 0){$/;"	f	class:VizBlockWorld	access:public	signature:(int r, int g, int b, int viewport = 0)
set_color	pixel.h	/^        void set_color(const GrayColor &gray){$/;"	f	class:GrayPixel2D	access:public	signature:(const GrayColor &gray)
set_color	pixel.h	/^        void set_color(const GrayColor &gray){$/;"	f	class:GrayPixel3D	access:public	signature:(const GrayColor &gray)
set_color	pixel.h	/^        void set_color(const RgbColor &rgb){$/;"	f	class:RgbPixel2D	access:public	signature:(const RgbColor &rgb)
set_color	pixel.h	/^        void set_color(const RgbColor &rgb){$/;"	f	class:RgbPixel3D	access:public	signature:(const RgbColor &rgb)
set_container	graph.h	/^        void set_container(GraphContainer *g){$/;"	f	class:m_graph::BaseGraph	access:public	signature:(GraphContainer *g)
set_def_cloud	vizblockworld.h	/^        void set_def_cloud(pcl::PointCloud<PointT>::Ptr cloud){ _cloud = cloud; }$/;"	f	class:VizBlockWorld	access:public	signature:(pcl::PointCloud<PointT>::Ptr cloud)
set_location	pixel.h	/^        void set_location(float x, float y, float z){$/;"	f	class:GrayPixel3D	access:public	signature:(float x, float y, float z)
set_location	pixel.h	/^        void set_location(float x, float y, float z){$/;"	f	class:RgbPixel3D	access:public	signature:(float x, float y, float z)
set_location	pixel.h	/^        void set_location(int x, int y){$/;"	f	class:GrayPixel2D	access:public	signature:(int x, int y)
set_location	pixel.h	/^        void set_location(int x, int y){$/;"	f	class:RgbPixel2D	access:public	signature:(int x, int y)
set_max_weight	component.h	/^        inline void set_max_weight(double w){$/;"	f	class:Component	access:public	signature:(double w)
set_offset	vizblockworld.h	/^        void set_offset(float x, float y, float z){ _x_offset = x; _y_offset = y; _z_offset = z; }$/;"	f	class:VizBlockWorld	access:public	signature:(float x, float y, float z)
set_render	vizblockworld.h	/^        void set_render(){$/;"	f	class:VizBlockWorld	access:public	signature:()
set_view	vizblockworld.h	/^        void set_view(std::string object){ _viewer->resetCameraViewpoint(object); }$/;"	f	class:VizBlockWorld	access:public	signature:(std::string object)
show	pixelworld2d.h	/^        void show();$/;"	p	class:PixelWorld2D	access:public	signature:()
show	pixelworld2d.h	/^void PixelWorld2D<T>::show(){$/;"	f	class:PixelWorld2D	signature:()
signature_t	emd.h	/^} signature_t;$/;"	t	typeref:struct:__anon1
size	cluster_node.h	/^    int size;$/;"	m	struct:TrNode	access:public
size	component.h	/^        inline int size() const{$/;"	f	class:Component	access:public	signature:() const
slip2next_cloud	main.cpp	/^void slip2next_cloud(PointCloudPtr cloud, const RgbColor &c){$/;"	f	signature:(PointCloudPtr cloud, const RgbColor &c)
slip2next_cloud	main.cpp	/^void slip2next_cloud(const std::string &fname){$/;"	f	signature:(const std::string &fname)
slip2next_mesh	main.cpp	/^void slip2next_mesh(const std::string &fname){$/;"	f	signature:(const std::string &fname)
sourceId	graph.h	/^        inline NodeId sourceId(const EdgeId& id) const{$/;"	f	class:m_graph::BaseGraph	access:public	signature:(const EdgeId& id) const
sourceId	graph.h	/^        inline NodeId sourceId(const EdgeId& id){$/;"	f	class:m_graph::BaseGraph	access:public	signature:(const EdgeId& id)
spatial_distance	pixel.h	/^        static double spatial_distance(const GrayPixel2D &a, const GrayPixel2D &b){$/;"	f	class:GrayPixel2D	access:public	signature:(const GrayPixel2D &a, const GrayPixel2D &b)
spatial_distance	pixel.h	/^        static double spatial_distance(const GrayPixel3D &a, const GrayPixel3D &b){$/;"	f	class:GrayPixel3D	access:public	signature:(const GrayPixel3D &a, const GrayPixel3D &b)
spatial_distance	pixel.h	/^        static double spatial_distance(const RgbPixel2D &a, const RgbPixel2D &b){$/;"	f	class:RgbPixel2D	access:public	signature:(const RgbPixel2D &a, const RgbPixel2D &b)
spatial_distance	pixel.h	/^        static double spatial_distance(const RgbPixel3D &a, const RgbPixel3D &b){$/;"	f	class:RgbPixel3D	access:public	signature:(const RgbPixel3D &a, const RgbPixel3D &b)
sum_ctr	cluster_node.h	/^        Point sum_ctr;         \/\/!< Weighted sum of barycenters$/;"	m	class:ClusterNode	access:public
target	main.cpp	/^string target;$/;"	v
targetId	graph.h	/^        inline NodeId targetId(const EdgeId& id) const{$/;"	f	class:m_graph::BaseGraph	access:public	signature:(const EdgeId& id) const
targetId	graph.h	/^        inline NodeId targetId(const EdgeId& id){$/;"	f	class:m_graph::BaseGraph	access:public	signature:(const EdgeId& id)
to	emd.h	/^  int to;               \/* Feature number in signature 2 *\/$/;"	m	struct:flow_t	access:public
to_matrix_graph	graph.h	/^    void to_matrix_graph( ){$/;"	f	class:m_graph::GraphUtil	access:public	signature:( )
tot_area	cluster_node.h	/^        double tot_area;       \/\/!< Total area of the cluster$/;"	m	class:ClusterNode	access:public
transform_pointcloud	vizblockworld.cpp	/^void transform_pointcloud(const pcl::PointCloud<PointT> &cloud_in,$/;"	f	signature:(const pcl::PointCloud<PointT> &cloud_in, pcl::PointCloud<PointT> &cloud_out, const Eigen::Matrix4f &transform)
transform_pointcloud	vizblockworld.h	/^void transform_pointcloud(const pcl::PointCloud<PointT> &cloud_in,$/;"	p	signature:(const pcl::PointCloud<PointT> &cloud_in, pcl::PointCloud<PointT> &cloud_out, const Eigen::Matrix4f &transform)
triangles	cluster_node.h	/^        List triangles;        \/\/!< All the triangles within the cluster$/;"	m	class:ClusterNode	access:public
triangles	cluster_node.h	/^    void **triangles;$/;"	m	struct:TrNode	access:public
triangles_of_component	triangulate.cpp	/^void MyTriangulation::triangles_of_component(int root, std::vector<Triangle*> *triangles)const{$/;"	f	class:MyTriangulation	signature:(int root, std::vector<Triangle*> *triangles) const
triangles_of_component	triangulate.h	/^        void triangles_of_component(int root, std::vector<Triangle*> *t)const;$/;"	p	class:MyTriangulation	access:public	signature:(int root, std::vector<Triangle*> *t) const
type	cluster_node.h	/^    unsigned char type;$/;"	m	struct:TrNode	access:public
unweighted_graphmodel	triangulate.cpp	/^void MyTriangulation::unweighted_graphmodel(BinaryTree *tree){$/;"	f	class:MyTriangulation	signature:(BinaryTree *tree)
unweighted_graphmodel	triangulate.h	/^        void unweighted_graphmodel(BinaryTree *tree);$/;"	p	class:MyTriangulation	access:protected	signature:(BinaryTree *tree)
val	emd.cpp	/^    double val;$/;"	m	struct:node1_t	file:	access:public
val	emd.cpp	/^    double val;$/;"	m	struct:node2_t	file:	access:public
vertex_coloring	util.h	/^bool vertex_coloring(m_graph::VizGraph<T, int> &imgModel){$/;"	f	signature:(m_graph::VizGraph<T, int> &imgModel)
vertex_node	graph.h	/^enum vertex_node_t { vertex_node };$/;"	e	enum:vertex_node_t
vertex_node_t	graph.h	/^enum vertex_node_t { vertex_node };$/;"	g
visualize_correspondence	icp.h	/^      void visualize_correspondence(VizBlockWorld *viz, int view) const;$/;"	p	class:IterativeClosestPoint	access:public	signature:(VizBlockWorld *viz, int view) const
viz	main.cpp	/^MyTriangulation vizMesh(&viz);$/;"	v
viz	main.cpp	/^VizBlockWorld viz;$/;"	v
vizMesh2	main.cpp	/^MyTriangulation *vizMesh2 = NULL;$/;"	v
viz_component	triangulate.cpp	/^std::string MyTriangulation::viz_component(const std::vector<Triangle*> &triangles, const RgbColor &color)const{$/;"	f	class:MyTriangulation	signature:(const std::vector<Triangle*> &triangles, const RgbColor &color) const
viz_component	triangulate.h	/^        std::string viz_component(const std::vector<Triangle*> &triangles,$/;"	p	class:MyTriangulation	access:public	signature:(const std::vector<Triangle*> &triangles, const m_opencv::RgbColor &color) const
viz_next_level	triangulate.cpp	/^void MyTriangulation::viz_next_level(){$/;"	f	class:MyTriangulation	signature:()
viz_next_level	triangulate.h	/^        void viz_next_level();$/;"	p	class:MyTriangulation	access:public	signature:()
viz_previous_level	triangulate.cpp	/^void MyTriangulation::viz_previous_level(){$/;"	f	class:MyTriangulation	signature:()
viz_previous_level	triangulate.h	/^        void viz_previous_level();$/;"	p	class:MyTriangulation	access:public	signature:()
wOutput_	icp.h	/^      std::vector<float> wOutput_;$/;"	m	class:IterativeClosestPoint	access:protected
weight	cluster_node.h	/^    double weight;$/;"	m	struct:TrNode	access:public
weights	cluster_node.cpp	/^BinaryTree::EdgeWeightsMap ClusterNode::weights = hierarchyTree.edge_weights();$/;"	m	class:ClusterNode	file:
weights	cluster_node.h	/^        static BinaryTree::EdgeWeightsMap weights;$/;"	m	class:ClusterNode	access:private
white_color	pixel.h	/^        static GrayColor white_color(){$/;"	f	class:GrayPixel2D	access:public	signature:()
write2dot	graph.h	/^    void write2dot(std::string filename){$/;"	f	class:m_graph::GraphUtil	access:public	signature:(std::string filename)
~AutoUniGraph	graph.h	/^        virtual ~AutoUniGraph (){$/;"	f	class:m_graph::AutoUniGraph	access:public	signature:()
~BaseGraph	graph.h	/^        virtual ~BaseGraph() {$/;"	f	class:m_graph::BaseGraph	access:public	signature:()
~ClusterNode	cluster_node.h	/^        virtual ~ClusterNode() {$/;"	f	class:ClusterNode	access:public	signature:()
~GraphUtil	graph.h	/^    virtual ~GraphUtil (){ };$/;"	f	class:m_graph::GraphUtil	access:public	signature:()
~ManualUniGraph	graph.h	/^        virtual ~ManualUniGraph (){ };$/;"	f	class:m_graph::ManualUniGraph	access:public	signature:()
~MyTriangulation	triangulate.h	/^        virtual ~MyTriangulation (){ };$/;"	f	class:MyTriangulation	access:public	signature:()
~PixelWorld2D	pixelworld2d.h	/^        virtual ~PixelWorld2D ();$/;"	p	class:PixelWorld2D	access:public	signature:()
~PixelWorld2D	pixelworld2d.h	/^PixelWorld2D<T>::~PixelWorld2D()$/;"	f	class:PixelWorld2D	signature:()
~PixelWorld3D	pixelworld3d.h	/^        virtual ~PixelWorld3D(){ };$/;"	f	class:PixelWorld3D	access:public	signature:()
~Segment2D	segment2d.h	/^        virtual ~Segment2D(){ };$/;"	f	class:Segment2D	access:public	signature:()
~Segment3D	segment3d.h	/^        ~Segment3D(){ };$/;"	f	class:Segment3D	access:public	signature:()
~TrNode	cluster_node.h	/^    ~TrNode(){$/;"	f	struct:TrNode	access:public	signature:()
